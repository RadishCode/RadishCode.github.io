{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"redis笔记","slug":"redis笔记","date":"2019-09-12T11:02:43.000Z","updated":"2019-09-12T11:06:24.270Z","comments":true,"path":"2019/09/12/redis笔记/","link":"","permalink":"http://yoursite.com/2019/09/12/redis笔记/","excerpt":"","text":"Redis1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品 • 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 2. 下载安装 1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 3. 命令操作 1. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 4. 持久化 1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 5. Java客户端 Jedis * Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); * Jedis操作各种redis中的数据结构 1) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 //存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); } //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); } /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } }案例：案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 * 注意：使用redis缓存一些不经常发生变化的数据。 * 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"Ajax和Json","slug":"Ajax和Json","date":"2019-09-10T01:57:56.000Z","updated":"2019-09-10T02:00:40.846Z","comments":true,"path":"2019/09/10/Ajax和Json/","link":"","permalink":"http://yoursite.com/2019/09/10/Ajax和Json/","excerpt":"","text":"AJAX和JSON1. AJAX： 2. JSONAJAX：1. 概念： ASynchronous JavaScript And XML 异步的JavaScript 和 XML 1. 异步和同步：客户端和服务器端相互通信的基础上 * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 提升用户的体验 2. 实现方式： 1. 原生的JS实现方式（了解） //1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); } else {// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } //2. 建立连接 /* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */ xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true); //3.发送请求 xmlhttp.send(); //4.接受并处理来自服务器的响应结果 //获取方式 ：xmlhttp.responseText //什么时候获取？当服务器响应成功后再获取 //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。 xmlhttp.onreadystatechange=function() { //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); } } 2. JQeury实现方式 1. $.ajax() * 语法：$.ajax({键值对}); //使用$.ajax()发送异步请求 $.ajax({ url:&quot;ajaxServlet1111&quot; , // 请求路径 type:&quot;POST&quot; , //请求方式 //data: &quot;username=jack&amp;age=23&quot;,//请求参数 data:{&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23}, success:function (data) { alert(data); },//响应成功后的回调函数 error:function () { alert(&quot;出错啦...&quot;) },//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 }); 2. $.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 3. $.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型JSON：1. 概念： JavaScript Object Notation JavaScript对象表示法 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); var p = {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;}; * json现在多用于存储和交换文本信息的语法 * 进行数据的传输 * JSON 比 XML 更小、更快，更易解析。 2. 语法： 1. 基本规则 * 数据在名称/值对中：json数据是由键值对构成的 * 键用引号(单双都行)引起来，也可以不使用引号 * 值得取值类型： 1. 数字（整数或浮点数） 2. 字符串（在双引号中） 3. 逻辑值（true 或 false） 4. 数组（在方括号中） {&quot;persons&quot;:[{},{}]} 5. 对象（在花括号中） {&quot;address&quot;:{&quot;province&quot;：&quot;陕西&quot;....}} 6. null * 数据由逗号分隔：多个键值对由逗号分隔 * 花括号保存对象：使用{}定义json 格式 * 方括号保存数组：[] 2. 获取数据: 1. json对象.键名 2. json对象[&quot;键名&quot;] 3. 数组对象[索引] 4. 遍历 //1.定义基本格式 var person = {&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true}; var ps = [{&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true}, {&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true}, {&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false}]; //获取person对象中所有的键和值 //for in 循环 /* for(var key in person){ //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]); }*/ //获取ps中的所有值 for (var i = 0; i &lt; ps.length; i++) { var p = ps[i]; for(var key in p){ alert(key+&quot;:&quot;+p[key]); } } 3. JSON数据和Java对象的相互转换 * JSON解析器： * 常见的解析器：Jsonlib，Gson，fastjson，jackson 1. JSON转为Java对象 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. readValue(json字符串数据,Class) 2. Java对象转换JSON 1. 使用步骤： 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. 转换方法： * writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 * writeValueAsString(obj):将对象转为json字符串 2. 注解： 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 3. 复杂java对象转换 1. List：数组 2. Map：对象格式一致案例：* 校验用户名是否存在 1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案： 1. $.get(type):将最后一个参数type指定为&quot;json&quot; 2. 在服务器端设置MIME类型 response.setContentType(&quot;application/json;charset=utf-8&quot;);","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Ajax,Json","slug":"Ajax-Json","permalink":"http://yoursite.com/tags/Ajax-Json/"}]},{"title":"JQuery高级笔记","slug":"JQuery高级笔记","date":"2019-09-10T01:52:52.000Z","updated":"2019-09-10T01:55:15.208Z","comments":true,"path":"2019/09/10/JQuery高级笔记/","link":"","permalink":"http://yoursite.com/2019/09/10/JQuery高级笔记/","excerpt":"","text":"JQuery高级1. JQuery 高级 1. 动画 2. 遍历 3. 事件绑定 4. 案例 5. 插件JQuery 高级1. 动画 1. 三种方式显示和隐藏元素 1. 默认显示和隐藏方式 1. show([speed,[easing],[fn]]) 1. 参数： 1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) 2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot; * swing：动画执行时效果是 先慢，中间快，最后又慢 * linear：动画执行时速度是匀速的 3. fn：在动画完成时执行的函数，每个元素执行一次。 2. hide([speed,[easing],[fn]]) 3. toggle([speed],[easing],[fn]) 2. 滑动显示和隐藏方式 1. slideDown([speed],[easing],[fn]) 2. slideUp([speed,[easing],[fn]]) 3. slideToggle([speed],[easing],[fn]) 3. 淡入淡出显示和隐藏方式 1. fadeIn([speed],[easing],[fn]) 2. fadeOut([speed],[easing],[fn]) 3. fadeToggle([speed,[easing],[fn]]) 2. 遍历 1. js的遍历方式 * for(初始化值;循环结束条件;步长) 2. jq的遍历方式 1. jq对象.each(callback) 1. 语法： jquery对象.each(function(index,element){}); * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 2. 回调函数返回值： * true:如果当前function返回为false，则结束循环(break)。 * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) 2. $.each(object, [callback]) 3. for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 3. 事件绑定 1. jquery标准的绑定方式 * jq对象.事件方法(回调函数)； * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 * 表单对象.submit();//让表单提交 2. on绑定事件/off解除绑定 * jq对象.on(&quot;事件名称&quot;,回调函数) * jq对象.off(&quot;事件名称&quot;) * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 3. 事件切换：toggle * jq对象.toggle(fn1,fn2...) * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2..... * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 4. 案例 1. 广告显示和隐藏 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt; &lt;style&gt; #content{width:100%;height:500px;background:#999} &lt;/style&gt; &lt;!--引入jquery--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 需求： 1. 当页面加载完，3秒后。自动显示广告 2. 广告显示5秒后，自动消失。 分析： 1. 使用定时器来完成。setTimeout (执行一次定时器) 2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display 3. 使用 show/hide方法来完成广告的显示 */ //入口函数，在页面加载完成之后，定义定时器，调用这两个方法 $(function () { //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); }); //显示广告 function adShow() { //获取广告div，调用显示方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); } //隐藏广告 function adHide() { //获取广告div，调用隐藏方法 $(&quot;#ad&quot;).hide(&quot;slow&quot;); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 整体的DIV --&gt; &lt;div&gt; &lt;!-- 广告DIV --&gt; &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt; &lt;img style=&quot;width:100%&quot; src=&quot;../img/adv.jpg&quot; /&gt; &lt;/div&gt; &lt;!-- 下方正文部分 --&gt; &lt;div id=&quot;content&quot;&gt; 正文部分 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2. 抽奖 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jquery案例之抽奖&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script language=&apos;javascript&apos; type=&apos;text/javascript&apos;&gt; /* 分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 * 定义数组，存放图片资源路径 * 生成随机数。数组索引 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 */ var imgs = [&quot;../img/man00.jpg&quot;, &quot;../img/man01.jpg&quot;, &quot;../img/man02.jpg&quot;, &quot;../img/man03.jpg&quot;, &quot;../img/man04.jpg&quot;, &quot;../img/man05.jpg&quot;, &quot;../img/man06.jpg&quot;, ]; var startId;//开始定时器的id var index;//随机角标 $(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); //1. 给开始按钮绑定单击事件 $(&quot;#startID&quot;).click(function () { // 1.1 定义循环定时器 20毫秒执行一次 startId = setInterval(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false); //1.2生成随机角标 0-6 index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999 //1.3设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); },20); }); //2. 给结束按钮绑定单击事件 $(&quot;#stopID&quot;).click(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); // 1.1 停止定时器 clearInterval(startId); // 1.2 给大相框设置src属性 $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide(); //显示1秒之后 $(&quot;#img2ID&quot;).show(1000); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 小像框 --&gt; &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt; &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt; &lt;/div&gt; &lt;!-- 大像框 --&gt; &lt;div style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt; &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt; &lt;/div&gt; &lt;!-- 开始按钮 --&gt; &lt;input id=&quot;startID&quot; type=&quot;button&quot; value=&quot;点击开始&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;!-- 停止按钮 --&gt; &lt;input id=&quot;stopID&quot; type=&quot;button&quot; value=&quot;点击停止&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;/body&gt; &lt;/html&gt; 5. 插件：增强JQuery的功能 1. 实现方式： 1. $.fn.extend(object) * 增强通过Jquery获取的对象的功能 $(&quot;#id&quot;) 2. $.extend(object) * 增强JQeury对象自身的功能 $/jQuery","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"JQuery基础笔记","slug":"JQuery基础笔记","date":"2019-09-07T11:19:56.000Z","updated":"2019-09-07T11:21:05.111Z","comments":true,"path":"2019/09/07/JQuery基础笔记/","link":"","permalink":"http://yoursite.com/2019/09/07/JQuery基础笔记/","excerpt":"","text":"知识点： JQuery 基础：1. 概念 2. 快速入门 3. JQuery对象和JS对象区别与转换 4. 选择器 5. DOM操作 6. 案例 JQuery 基础：1. 概念： 一个JavaScript框架。简化JS开发 * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 2. 快速入门 1. 步骤： 1. 下载JQuery * 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） * jquery-xxx.js 与 jquery-xxx.min.js区别： 1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 2. 导入JQuery的js文件：导入min.js文件 3. 使用 var div1 = $(&quot;#div1&quot;); alert(div1.html()); 3. JQuery对象和JS对象区别与转换 1. JQuery对象在操作时，更加方便。 2. JQuery对象和js对象方法不通用的. 3. 两者相互转换 * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引) * js -- &gt; jq : $(js对象) 4. 选择器：筛选具有相似特征的元素(标签) 1. 基本操作学习： 1. 事件绑定 //1.获取b1按钮 $(&quot;#b1&quot;).click(function(){ alert(&quot;abc&quot;); }); 2. 入口函数 $(function () { }); window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 3. 样式控制：css方法 // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;); $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); 2. 分类 1. 基本选择器 1. 标签选择器（元素选择器） * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素 2. id选择器 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素 3. 类选择器 * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素 4. 并集选择器： * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素 2. 层级选择器 1. 后代选择器 * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素 2. 子选择器 * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 3. 属性选择器 1. 属性名称选择器 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2. 属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器 3. 复合属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;][]...&quot;) 包含多个属性条件的选择器 4. 过滤选择器 1. 首元素选择器 * 语法： :first 获得选择的元素中的第一个元素 2. 尾元素选择器 * 语法： :last 获得选择的元素中的最后一个元素 3. 非元素选择器 * 语法： :not(selector) 不包括指定内容的元素 4. 偶数选择器 * 语法： :even 偶数，从 0 开始计数 5. 奇数选择器 * 语法： :odd 奇数，从 0 开始计数 6. 等于索引选择器 * 语法： :eq(index) 指定索引元素 7. 大于索引选择器 * 语法： :gt(index) 大于指定索引元素 8. 小于索引选择器 * 语法： :lt(index) 小于指定索引元素 9. 标题选择器 * 语法： :header 获得标题（h1~h6）元素，固定写法 5. 表单过滤选择器 1. 可用元素选择器 * 语法： :enabled 获得可用元素 2. 不可用元素选择器 * 语法： :disabled 获得不可用元素 3. 选中选择器 * 语法： :checked 获得单选/复选框选中的元素 4. 选中选择器 * 语法： :selected 获得下拉框选中的元素 5. DOM操作 1. 内容操作 1. html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; 2. text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 3. val()： 获取/设置元素的value属性值 2. 属性操作 1. 通用属性操作 1. attr(): 获取/设置元素的属性 2. removeAttr():删除属性 3. prop():获取/设置元素的属性 4. removeProp():删除属性 * attr和prop区别？ 1. 如果操作的是元素的固有属性，则建议使用prop 2. 如果操作的是元素自定义的属性，则建议使用attr 2. 对class属性操作 1. addClass():添加class属性值 2. removeClass():删除class属性值 3. toggleClass():切换class属性 * toggleClass(&quot;one&quot;): * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。 如果元素对象上不存在class=&quot;one&quot;，则添加 4. css(): 3. CRUD操作: 1. append():父元素将子元素追加到末尾 * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 2. prepend():父元素将子元素追加到开头 * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 3. appendTo(): * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 4. prependTo()： * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 5. after():添加元素到元素后边 * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 6. before():添加元素到元素前边 * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 7. insertAfter() * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 8. insertBefore() * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 9. remove():移除元素 * 对象.remove():将对象删除掉 10. empty():清空元素的所有后代元素。 * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"web数据库乱码编码","slug":"web数据库乱码编码","date":"2019-08-30T13:43:53.000Z","updated":"2019-08-30T14:05:59.021Z","comments":true,"path":"2019/08/30/web数据库乱码编码/","link":"","permalink":"http://yoursite.com/2019/08/30/web数据库乱码编码/","excerpt":"","text":"web文本中的乱码问题问题简介： 从数据库获取学生数据时，中文不会出现乱码。但是当增加数据的时候，会出现乱码。乱码全为？？？ 自我思考： 中文乱码和但是英文，数学不会出现乱码。很大程度是字符集的编码问题。 但是特殊的是：从数据库获取数据不会乱码。当web上增加数据时，就会出现乱码 检查jsp, java， 数据库表的编码格式都是“utf-8”，这就很难受 最后想到应该是数据库的问题，想到安装时。数据库默认的字符集时latin1,并没有修改 于是修改一下，进行测试 修改字符集 1. 2. 问题最后解决了","categories":[],"tags":[{"name":"编码问题","slug":"编码问题","permalink":"http://yoursite.com/tags/编码问题/"}]},{"title":"NoClassDefFounfError","slug":"NoClassDefFounfError","date":"2019-08-28T13:35:49.000Z","updated":"2019-08-28T14:11:25.039Z","comments":true,"path":"2019/08/28/NoClassDefFounfError/","link":"","permalink":"http://yoursite.com/2019/08/28/NoClassDefFounfError/","excerpt":"","text":"问题简介出现 在开发一个登陆界面的web项目时，需要用户输入的账号和密码和数据存储的账号和密码做对比，来判断用户和密码是否正确。因此使用到了Druid连接池jar包 写好了，数据库连接池的工具类，在单元测试中可以正确的运行，但是在web上运行是就会报错 提示错误 问题解决数据库连接池jar路径问题修改前：修改后：","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"css代码不恰当提示解决","slug":"css代码不恰当提示解决","date":"2019-08-22T23:58:33.000Z","updated":"2019-08-23T00:35:08.000Z","comments":true,"path":"2019/08/23/css代码不恰当提示解决/","link":"","permalink":"http://yoursite.com/2019/08/23/css代码不恰当提示解决/","excerpt":"","text":"css设置web背景图遇见的问题问题 提示信息 解释检查发现相似的css内容，它能被简化形式 问题解决修改代码后：","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"解决banner居中显示问题","slug":"解决banner居中显示问题","date":"2019-08-14T12:49:11.000Z","updated":"2019-08-14T12:50:53.426Z","comments":true,"path":"2019/08/14/解决banner居中显示问题/","link":"","permalink":"http://yoursite.com/2019/08/14/解决banner居中显示问题/","excerpt":"","text":"地址： https://www.cnblogs.com/chenchenhao/p/9889628.html 在做web界面时，出现了窗口缩放时，banner图片布局中的问题，在博客园找到了解决方法 大家在做项目的时候有没有遇到一个问题呢 就是一张图片宽度100% 在缩放屏幕的时候图片会被压缩变形！！！那么怎么才能实现图片始终居中而不被压缩变形呢？ 接下来让我带领大家解决这个问题 请看代码↓↓↓↓↓↓↓1234567891011121314151617181920212223242526272829303132&lt;style&gt; .bannerbox &#123; width: 100%; position: relative; overflow: hidden; height: 500px; border: 1px solid red; &#125; .banner &#123; width: 1920px; /*图片宽度*/ position: absolute; left: 50%; margin-left: -960px; /*图片宽度的一半*/ &#125; &lt;/style&gt; &lt;div class='bannerbox'&gt; &lt;div class='banner'&gt; &lt;img src=\"./banner.png\"&gt; &lt;/div&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"网页轮播图","slug":"网页轮播图","date":"2019-08-09T12:29:06.000Z","updated":"2019-08-09T12:44:28.305Z","comments":true,"path":"2019/08/09/网页轮播图/","link":"","permalink":"http://yoursite.com/2019/08/09/网页轮播图/","excerpt":"","text":"网页页面的轮播图 1.setInterval(fun, time) fun为函数，time为毫秒 2.使用document.getElementById()来获取body里的对象 如：var img = document.getElementById() 3.使用数组来存储图片的路径123456789101112131415161718192021222324252627&lt;body&gt; &lt;img src=\"./images/1.jpg\" id = \"pic\"&gt; &lt;script&gt; var imgArr = new Array(0); imgArr.push(\"./images/1.jpg\"); imgArr.push(\"./images/4.jpg\"); imgArr.push(\"./images/off.jpg\"); imgArr.push(\"./images/on.jpg\"); var img = document.getElementById(\"pic\"); setInterval(slide, 1000); var index = 0; function slide()&#123; if(index == imgArr.length - 1)&#123; img.src = imgArr[index]; index -= imgArr.length - 1; &#125; else &#123; img.src = imgArr[index]; index += 1; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 代码实现","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"html背景图自适应","slug":"html背景图自适应","date":"2019-08-08T11:05:33.000Z","updated":"2019-08-08T11:13:31.246Z","comments":true,"path":"2019/08/08/html背景图自适应/","link":"","permalink":"http://yoursite.com/2019/08/08/html背景图自适应/","excerpt":"","text":"账号注册页面设计出现问题网页背景图片不能根据浏览器的变大而变大,会出现空白区12345body&#123; background:url('./测试图片/1.jpeg'); background-repeat:no-repeat; background-size:100% 100%&#125;","categories":[],"tags":[{"name":"hmtl","slug":"hmtl","permalink":"http://yoursite.com/tags/hmtl/"}]},{"title":"坦克大战-第四天","slug":"坦克大战-第四天","date":"2019-08-04T13:39:25.000Z","updated":"2019-08-05T02:49:53.348Z","comments":true,"path":"2019/08/04/坦克大战-第四天/","link":"","permalink":"http://yoursite.com/2019/08/04/坦克大战-第四天/","excerpt":"","text":"敌方坦克 1.增加了敌方坦克的随机运动和随机发射子弹,使用了Random类 2.在游戏窗口类中,新增一个成员变量为List enemyTanks = new Arraylist&lt;&gt;(),用于存放多个敌方坦克对象 3.增加了坦克越界的边界检查,如果坦克的位置出界就把位置赋值为老的位置 123456789// 在Direction枚举对象中,增加随机方向的方法public enum Direction &#123; UP, DOWN, LEFT, RIGHT; private static Random rand = new Random(); public static Direction randomDir() &#123; return values()[rand.nextInt(values().length)]; &#125;&#125; 在敌方坦克类(Tank)中加入随机方法的方法 123456private Random rand = New Random();private void setDirection() &#123; if(rand.nextInt(100) &gt; 95)&#123; // 当随机数大于95时再随机设置方式 this.direction = Direction.randomDir(); &#125;&#125; 在游戏窗口类中增加List 1234// 存放敌方坦克对象List&lt;Tank&gt; enemyTanks = new ArrayList&lt;&gt;();// 监听键盘的Y按键, 当按键Y抬起时// add(new Tank(200, 200 , Direction.randomDir, ,Group.Bad)); 增加边界检测 当坦克出界是, 使上步位置赋值给现在的位置, 在进行绘制坦克123456789101112131415161718192021222324252627282930private void boundsCheck() &#123; if(x &lt; 0 || y &lt; 30 || x + this.WIDTH &gt; gf.GAME_WIDTH || y + this.HEIGHT &gt; gf.GAME_HEIGHT) &#123; this.x =this.oldX; this.y = this.oldY; &#125;&#125;// 将此方法加入坦克类的move()方法的最下方// 5):根据方向一直移动private void move() &#123; this.oldX = x; this.oldY = y; setDirection(); switch (direction) &#123; case UP: y -= SPEED; break; case DOWN: y += SPEED; break; case RIGHT: x += SPEED; break; case LEFT: x -= SPEED; break; &#125; boundsCheck(); fire();&#125; 随机时刻发出子弹也是使用Random的对象, 和设置方向的方式一样。上方代码已经创建了Random的对象，因此直接使用rand调用nextInt()方法即可 123456789// 此方法加入move()方法的下方private void fire() &#123; if(rand.nextInt(100) &gt; 95) &#123; if(gf == null)&#123; gf = GameFrame.getInstance; &#125; gf.add(new Bullet(x, y, direction, group)); &#125;&#125; 程序运行结果:","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"坦克大战-第三天","slug":"坦克大战-第三天","date":"2019-08-02T07:43:02.000Z","updated":"2019-08-02T08:49:36.088Z","comments":true,"path":"2019/08/02/坦克大战-第三天/","link":"","permalink":"http://yoursite.com/2019/08/02/坦克大战-第三天/","excerpt":"","text":"主要内容增加了按键控制坦克的方向 监听键盘上下左右按键，进行控制坦克的运行123456789101112131415161718192021222324252627282930313233343536373839404142// 4):设置坦克方向private void setDirection() &#123; if (!isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; !isD) &#123; isMoving = false; &#125; else &#123; isMoving = true; &#125; if (isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; !isD) &#123; direction = Direction.UP; &#125; if (!isU &amp;&amp; isR &amp;&amp; !isL &amp;&amp; !isD) &#123; direction = Direction.RIGHT; &#125; if (!isU &amp;&amp; !isR &amp;&amp; isL &amp;&amp; !isD) &#123; direction = Direction.LEFT; &#125; if (!isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; isD) &#123; direction = Direction.DOWN; &#125;&#125;// 5):根据方向一直移动private void move() &#123; if (!isMoving) &#123; return; &#125; switch (direction) &#123; case UP: y -= SPEED; break; case DOWN: y += SPEED; break; case RIGHT: x += SPEED; break; case LEFT: x -= SPEED; break; &#125;&#125; 解决游戏坦克图片闪动严重原因： 由于每次画图需要从内存中读取数据，在一点一点的绘制在窗口上。一边读取一边绘制。读取还为完成，就已经有部分绘制在电脑屏幕上。因此出现闪屏的情况。 解决办法：先将图片绘制在一个和窗口大小一致的offScreemImage上，然后再将该图片一次性画在窗口上。1234567891011121314@Overridepublic void update(Graphics g) &#123; if (offScreenImage == null) &#123; offScreenImage = this.createImage(GAME_WIDTH, GAME_HEIGHT); &#125; Graphics gOffScreen = offScreenImage.getGraphics(); Color c = gOffScreen.getColor(); gOffScreen.setColor(Color.BLACK); gOffScreen.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); gOffScreen.setColor(c); paint(gOffScreen); g.drawImage(offScreenImage, 0, 0, null);&#125; 画出了敌方坦克12345678910111213141516171819public void paint(Graphics g) &#123; switch (direction) &#123; case UP: g.drawImage(ImagesResource.badTankU, x, y, null); break; case DOWN: g.drawImage(ImagesResource.badTankD, x, y, null); break; case RIGHT: g.drawImage(ImagesResource.badTankR, x, y, null); break; case LEFT: g.drawImage(ImagesResource.badTankL, x, y, null); break; &#125; move();&#125; 增加子弹对象增加X按键，来释放子弹 为了控制子弹的发射速度，采取监听X按键抬起的信号 GameFrame类中，增加代码：123456789101112131415161718192021// 2):得到显卡的画笔public void paint(Graphics g) &#123; myTank.paint(g); if(enemyTank.isLive()) &#123; enemyTank.paint(g); &#125; if (bullets != null) &#123; for (int i = 0; i &lt; bullets.size(); i++) &#123; Bullet bullet = bullets.get(i); bullet.crashWithTank(enemyTank); if(!bullet.isLive()) &#123; bullets.remove(i); &#125;else &#123; bullet.paint(g); &#125; &#125; getBulletCount(g); &#125;&#125; 为了使子弹对象存在多个对象，将对象加入容器中子弹过多会产生内存泄漏，当子弹跑出屏幕或打到敌方坦克删除子弹对象 选择List集合框架中的ArrayList来存放子弹对象 ArrayList bullets = new ArrayList&lt;&gt;()123456789101112if (bullets != null) &#123; for (int i = 0; i &lt; bullets.size(); i++) &#123; Bullet bullet = bullets.get(i); bullet.crashWithTank(enemyTank); if(!bullet.isLive()) &#123; bullets.remove(i); &#125;else &#123; bullet.paint(g); &#125; &#125; getBulletCount(g);&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"坦克大战-第二天","slug":"坦克大战-第二天","date":"2019-07-31T00:46:58.000Z","updated":"2019-07-31T02:33:26.825Z","comments":true,"path":"2019/07/31/坦克大战-第二天/","link":"","permalink":"http://yoursite.com/2019/07/31/坦克大战-第二天/","excerpt":"","text":"坦克类的设计创建一个坦克的类 考虑坦克的属性(位置、方向、速度) 其中方向采用枚举（上、下、左、右） 加载坦克的图片 接受按键的触发，使坦克根据人的控制来动 代码实现方向枚举123Enum Direction &#123; UP, DOWN, LEFE, RIGHT&#125; 图片资源类（例如坦克图片）12345678910111213public class ImagesResource &#123; public static BufferedImage goodTankU, goodTankD, goodTankR, goodTankL; static&#123; try &#123; goodTankU = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankU.gif\")); goodTankD = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankD.gif\")); goodTankL = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankL.gif\")); goodTankR = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankR.gif\")); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 坦克类123456789101112131415161718192021222324252627282930/* 1):得到窗口传递的画笔，绘制自己 2):监听键盘按下 3):监听键盘抬起*/public class Tank &#123; private static final int SPEED = 5; // 坦克的速度 private int x, y; //坦克的初始位置 private Direction direction； // 坦克的方向 public Tank(int x, int y, Direction direction)&#123; this.x = x; this.y = y; this.direction = direction; &#125; // 1):得到窗口传递的画笔，绘制自己 public void paint (Graphics g) &#123; g.drawImage(ImagesResource.goodTankD, x, y, null); &#125; // 2):监听键盘按下 public void keyPressed(KeyEvent e) &#123; &#125; // 3):监听键盘抬起 public void keyReleased(KeyEvent e) &#123; &#125;&#125; 运行结果窗口增加键盘和窗口监听 在游戏窗口类构造器中见添加监听，并把监听信号选择性的传给坦克对象 敌方坦克不需要监听信号，自己的坦克需要。 窗口监听，来关闭程序（点击上方X，进行关闭程序） 12345678910111213141516171819202122232425262728// GameFrame的构造器增加监听public GameFrame ()&#123; . . //省略 ..... . // 键盘监听 this.addKeyListener(new KeyAdapte( @Override public void keyPressed(KeyEvent e) &#123; myTank.keyPressed(e); &#125; @Override public void keyReleased(KeyEvent e) &#123; myTank.keyReleased(e); &#125; )); // 窗口监听 this.addWindowListener(new WinodowAdapte()&#123; @Override public void windowClosing(WindowEvent e) &#123; // 关闭程序 System.exit(0); &#125; &#125;)&#125;","categories":[],"tags":[]},{"title":"坦克大战-第一天","slug":"坦克大战-第一天","date":"2019-07-30T14:19:37.000Z","updated":"2019-07-30T15:30:23.383Z","comments":true,"path":"2019/07/30/坦克大战-第一天/","link":"","permalink":"http://yoursite.com/2019/07/30/坦克大战-第一天/","excerpt":"","text":"第一天创建一个游戏窗口 新建一个GameFrame窗口类（单例设计模式） 设置游戏窗口的属性（长、宽、高、背景颜色、位置等） 给窗口一个画笔，进行绘制图形 在窗口画一个图形进行测试 将画笔交给坦克对象 1234567891011121314151617181920212223242526// 游戏的窗口/* 1):向外暴露自己的实例对象 2):得到显卡的画笔*/public class GameFrame extends Frame &#123; // 创建该类的私有化静态对象 private static final GameFrame instance = new GameFrame(); // 私有化构造器 private GameFrame()&#123; // 初始化窗口数据 this.setTitle(\"Tank War\"); // 窗口标题 this.setLocation(600, 200);// 窗口位置 this.setSize(800, 600);// 窗口大小 this.setVisible(true); // 显示窗口 &#125;; // 1):向外暴露自己的实例对象 public static GameFrame getInstance() &#123; return instance; &#125; // 2):得到显卡的画笔 public void paint(Graphics g) &#123; g.fillRect(100, 100, 50, 50); &#125;&#125; 主方法获取窗口实例对象123456public class Main &#123; public static void maiN(String[] args) &#123; // 获取窗口的实例对象 GameFrame.getInstance(); &#125;&#125; 输出结果","categories":[],"tags":[]},{"title":"坦克大战","slug":"坦克大战","date":"2019-07-30T12:31:38.000Z","updated":"2019-07-30T13:03:29.775Z","comments":true,"path":"2019/07/30/坦克大战/","link":"","permalink":"http://yoursite.com/2019/07/30/坦克大战/","excerpt":"","text":"坦克大战项目的目的 通过项目建立面向对象的设计思维，并复习OO，容器，网络、线程等基础知识 资料 1.阿里手册 2.GUI(不需要深入掌握) 项目安排 1.做一个游戏窗口并显示","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-28T08:49:02.323Z","updated":"2019-07-28T08:49:02.323Z","comments":true,"path":"2019/07/28/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}