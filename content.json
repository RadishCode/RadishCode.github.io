{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"JQuery基础笔记","slug":"JQuery基础笔记","date":"2019-09-07T11:19:56.000Z","updated":"2019-09-07T11:21:05.111Z","comments":true,"path":"2019/09/07/JQuery基础笔记/","link":"","permalink":"http://yoursite.com/2019/09/07/JQuery基础笔记/","excerpt":"","text":"知识点： JQuery 基础：1. 概念 2. 快速入门 3. JQuery对象和JS对象区别与转换 4. 选择器 5. DOM操作 6. 案例 JQuery 基础：1. 概念： 一个JavaScript框架。简化JS开发 * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 2. 快速入门 1. 步骤： 1. 下载JQuery * 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） * jquery-xxx.js 与 jquery-xxx.min.js区别： 1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 2. 导入JQuery的js文件：导入min.js文件 3. 使用 var div1 = $(&quot;#div1&quot;); alert(div1.html()); 3. JQuery对象和JS对象区别与转换 1. JQuery对象在操作时，更加方便。 2. JQuery对象和js对象方法不通用的. 3. 两者相互转换 * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引) * js -- &gt; jq : $(js对象) 4. 选择器：筛选具有相似特征的元素(标签) 1. 基本操作学习： 1. 事件绑定 //1.获取b1按钮 $(&quot;#b1&quot;).click(function(){ alert(&quot;abc&quot;); }); 2. 入口函数 $(function () { }); window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 3. 样式控制：css方法 // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;); $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); 2. 分类 1. 基本选择器 1. 标签选择器（元素选择器） * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素 2. id选择器 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素 3. 类选择器 * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素 4. 并集选择器： * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素 2. 层级选择器 1. 后代选择器 * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素 2. 子选择器 * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 3. 属性选择器 1. 属性名称选择器 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2. 属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器 3. 复合属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;][]...&quot;) 包含多个属性条件的选择器 4. 过滤选择器 1. 首元素选择器 * 语法： :first 获得选择的元素中的第一个元素 2. 尾元素选择器 * 语法： :last 获得选择的元素中的最后一个元素 3. 非元素选择器 * 语法： :not(selector) 不包括指定内容的元素 4. 偶数选择器 * 语法： :even 偶数，从 0 开始计数 5. 奇数选择器 * 语法： :odd 奇数，从 0 开始计数 6. 等于索引选择器 * 语法： :eq(index) 指定索引元素 7. 大于索引选择器 * 语法： :gt(index) 大于指定索引元素 8. 小于索引选择器 * 语法： :lt(index) 小于指定索引元素 9. 标题选择器 * 语法： :header 获得标题（h1~h6）元素，固定写法 5. 表单过滤选择器 1. 可用元素选择器 * 语法： :enabled 获得可用元素 2. 不可用元素选择器 * 语法： :disabled 获得不可用元素 3. 选中选择器 * 语法： :checked 获得单选/复选框选中的元素 4. 选中选择器 * 语法： :selected 获得下拉框选中的元素 5. DOM操作 1. 内容操作 1. html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; 2. text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 3. val()： 获取/设置元素的value属性值 2. 属性操作 1. 通用属性操作 1. attr(): 获取/设置元素的属性 2. removeAttr():删除属性 3. prop():获取/设置元素的属性 4. removeProp():删除属性 * attr和prop区别？ 1. 如果操作的是元素的固有属性，则建议使用prop 2. 如果操作的是元素自定义的属性，则建议使用attr 2. 对class属性操作 1. addClass():添加class属性值 2. removeClass():删除class属性值 3. toggleClass():切换class属性 * toggleClass(&quot;one&quot;): * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。 如果元素对象上不存在class=&quot;one&quot;，则添加 4. css(): 3. CRUD操作: 1. append():父元素将子元素追加到末尾 * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 2. prepend():父元素将子元素追加到开头 * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 3. appendTo(): * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 4. prependTo()： * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 5. after():添加元素到元素后边 * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 6. before():添加元素到元素前边 * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 7. insertAfter() * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 8. insertBefore() * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 9. remove():移除元素 * 对象.remove():将对象删除掉 10. empty():清空元素的所有后代元素。 * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"web数据库乱码编码","slug":"web数据库乱码编码","date":"2019-08-30T13:43:53.000Z","updated":"2019-08-30T14:05:59.021Z","comments":true,"path":"2019/08/30/web数据库乱码编码/","link":"","permalink":"http://yoursite.com/2019/08/30/web数据库乱码编码/","excerpt":"","text":"web文本中的乱码问题问题简介： 从数据库获取学生数据时，中文不会出现乱码。但是当增加数据的时候，会出现乱码。乱码全为？？？ 自我思考： 中文乱码和但是英文，数学不会出现乱码。很大程度是字符集的编码问题。 但是特殊的是：从数据库获取数据不会乱码。当web上增加数据时，就会出现乱码 检查jsp, java， 数据库表的编码格式都是“utf-8”，这就很难受 最后想到应该是数据库的问题，想到安装时。数据库默认的字符集时latin1,并没有修改 于是修改一下，进行测试 修改字符集 1. 2. 问题最后解决了","categories":[],"tags":[{"name":"编码问题","slug":"编码问题","permalink":"http://yoursite.com/tags/编码问题/"}]},{"title":"NoClassDefFounfError","slug":"NoClassDefFounfError","date":"2019-08-28T13:35:49.000Z","updated":"2019-08-28T14:11:25.039Z","comments":true,"path":"2019/08/28/NoClassDefFounfError/","link":"","permalink":"http://yoursite.com/2019/08/28/NoClassDefFounfError/","excerpt":"","text":"问题简介出现 在开发一个登陆界面的web项目时，需要用户输入的账号和密码和数据存储的账号和密码做对比，来判断用户和密码是否正确。因此使用到了Druid连接池jar包 写好了，数据库连接池的工具类，在单元测试中可以正确的运行，但是在web上运行是就会报错 提示错误 问题解决数据库连接池jar路径问题修改前：修改后：","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"css代码不恰当提示解决","slug":"css代码不恰当提示解决","date":"2019-08-22T23:58:33.000Z","updated":"2019-08-23T00:35:08.000Z","comments":true,"path":"2019/08/23/css代码不恰当提示解决/","link":"","permalink":"http://yoursite.com/2019/08/23/css代码不恰当提示解决/","excerpt":"","text":"css设置web背景图遇见的问题问题 提示信息 解释检查发现相似的css内容，它能被简化形式 问题解决修改代码后：","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"解决banner居中显示问题","slug":"解决banner居中显示问题","date":"2019-08-14T12:49:11.000Z","updated":"2019-08-14T12:50:53.426Z","comments":true,"path":"2019/08/14/解决banner居中显示问题/","link":"","permalink":"http://yoursite.com/2019/08/14/解决banner居中显示问题/","excerpt":"","text":"地址： https://www.cnblogs.com/chenchenhao/p/9889628.html 在做web界面时，出现了窗口缩放时，banner图片布局中的问题，在博客园找到了解决方法 大家在做项目的时候有没有遇到一个问题呢 就是一张图片宽度100% 在缩放屏幕的时候图片会被压缩变形！！！那么怎么才能实现图片始终居中而不被压缩变形呢？ 接下来让我带领大家解决这个问题 请看代码↓↓↓↓↓↓↓1234567891011121314151617181920212223242526272829303132&lt;style&gt; .bannerbox &#123; width: 100%; position: relative; overflow: hidden; height: 500px; border: 1px solid red; &#125; .banner &#123; width: 1920px; /*图片宽度*/ position: absolute; left: 50%; margin-left: -960px; /*图片宽度的一半*/ &#125; &lt;/style&gt; &lt;div class='bannerbox'&gt; &lt;div class='banner'&gt; &lt;img src=\"./banner.png\"&gt; &lt;/div&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"网页轮播图","slug":"网页轮播图","date":"2019-08-09T12:29:06.000Z","updated":"2019-08-09T12:44:28.305Z","comments":true,"path":"2019/08/09/网页轮播图/","link":"","permalink":"http://yoursite.com/2019/08/09/网页轮播图/","excerpt":"","text":"网页页面的轮播图 1.setInterval(fun, time) fun为函数，time为毫秒 2.使用document.getElementById()来获取body里的对象 如：var img = document.getElementById() 3.使用数组来存储图片的路径123456789101112131415161718192021222324252627&lt;body&gt; &lt;img src=\"./images/1.jpg\" id = \"pic\"&gt; &lt;script&gt; var imgArr = new Array(0); imgArr.push(\"./images/1.jpg\"); imgArr.push(\"./images/4.jpg\"); imgArr.push(\"./images/off.jpg\"); imgArr.push(\"./images/on.jpg\"); var img = document.getElementById(\"pic\"); setInterval(slide, 1000); var index = 0; function slide()&#123; if(index == imgArr.length - 1)&#123; img.src = imgArr[index]; index -= imgArr.length - 1; &#125; else &#123; img.src = imgArr[index]; index += 1; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 代码实现","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"html背景图自适应","slug":"html背景图自适应","date":"2019-08-08T11:05:33.000Z","updated":"2019-08-08T11:13:31.246Z","comments":true,"path":"2019/08/08/html背景图自适应/","link":"","permalink":"http://yoursite.com/2019/08/08/html背景图自适应/","excerpt":"","text":"账号注册页面设计出现问题网页背景图片不能根据浏览器的变大而变大,会出现空白区12345body&#123; background:url('./测试图片/1.jpeg'); background-repeat:no-repeat; background-size:100% 100%&#125;","categories":[],"tags":[{"name":"hmtl","slug":"hmtl","permalink":"http://yoursite.com/tags/hmtl/"}]},{"title":"坦克大战-第四天","slug":"坦克大战-第四天","date":"2019-08-04T13:39:25.000Z","updated":"2019-08-05T02:49:53.348Z","comments":true,"path":"2019/08/04/坦克大战-第四天/","link":"","permalink":"http://yoursite.com/2019/08/04/坦克大战-第四天/","excerpt":"","text":"敌方坦克 1.增加了敌方坦克的随机运动和随机发射子弹,使用了Random类 2.在游戏窗口类中,新增一个成员变量为List enemyTanks = new Arraylist&lt;&gt;(),用于存放多个敌方坦克对象 3.增加了坦克越界的边界检查,如果坦克的位置出界就把位置赋值为老的位置 123456789// 在Direction枚举对象中,增加随机方向的方法public enum Direction &#123; UP, DOWN, LEFT, RIGHT; private static Random rand = new Random(); public static Direction randomDir() &#123; return values()[rand.nextInt(values().length)]; &#125;&#125; 在敌方坦克类(Tank)中加入随机方法的方法 123456private Random rand = New Random();private void setDirection() &#123; if(rand.nextInt(100) &gt; 95)&#123; // 当随机数大于95时再随机设置方式 this.direction = Direction.randomDir(); &#125;&#125; 在游戏窗口类中增加List 1234// 存放敌方坦克对象List&lt;Tank&gt; enemyTanks = new ArrayList&lt;&gt;();// 监听键盘的Y按键, 当按键Y抬起时// add(new Tank(200, 200 , Direction.randomDir, ,Group.Bad)); 增加边界检测 当坦克出界是, 使上步位置赋值给现在的位置, 在进行绘制坦克123456789101112131415161718192021222324252627282930private void boundsCheck() &#123; if(x &lt; 0 || y &lt; 30 || x + this.WIDTH &gt; gf.GAME_WIDTH || y + this.HEIGHT &gt; gf.GAME_HEIGHT) &#123; this.x =this.oldX; this.y = this.oldY; &#125;&#125;// 将此方法加入坦克类的move()方法的最下方// 5):根据方向一直移动private void move() &#123; this.oldX = x; this.oldY = y; setDirection(); switch (direction) &#123; case UP: y -= SPEED; break; case DOWN: y += SPEED; break; case RIGHT: x += SPEED; break; case LEFT: x -= SPEED; break; &#125; boundsCheck(); fire();&#125; 随机时刻发出子弹也是使用Random的对象, 和设置方向的方式一样。上方代码已经创建了Random的对象，因此直接使用rand调用nextInt()方法即可 123456789// 此方法加入move()方法的下方private void fire() &#123; if(rand.nextInt(100) &gt; 95) &#123; if(gf == null)&#123; gf = GameFrame.getInstance; &#125; gf.add(new Bullet(x, y, direction, group)); &#125;&#125; 程序运行结果:","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"坦克大战-第三天","slug":"坦克大战-第三天","date":"2019-08-02T07:43:02.000Z","updated":"2019-08-02T08:49:36.088Z","comments":true,"path":"2019/08/02/坦克大战-第三天/","link":"","permalink":"http://yoursite.com/2019/08/02/坦克大战-第三天/","excerpt":"","text":"主要内容增加了按键控制坦克的方向 监听键盘上下左右按键，进行控制坦克的运行123456789101112131415161718192021222324252627282930313233343536373839404142// 4):设置坦克方向private void setDirection() &#123; if (!isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; !isD) &#123; isMoving = false; &#125; else &#123; isMoving = true; &#125; if (isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; !isD) &#123; direction = Direction.UP; &#125; if (!isU &amp;&amp; isR &amp;&amp; !isL &amp;&amp; !isD) &#123; direction = Direction.RIGHT; &#125; if (!isU &amp;&amp; !isR &amp;&amp; isL &amp;&amp; !isD) &#123; direction = Direction.LEFT; &#125; if (!isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; isD) &#123; direction = Direction.DOWN; &#125;&#125;// 5):根据方向一直移动private void move() &#123; if (!isMoving) &#123; return; &#125; switch (direction) &#123; case UP: y -= SPEED; break; case DOWN: y += SPEED; break; case RIGHT: x += SPEED; break; case LEFT: x -= SPEED; break; &#125;&#125; 解决游戏坦克图片闪动严重原因： 由于每次画图需要从内存中读取数据，在一点一点的绘制在窗口上。一边读取一边绘制。读取还为完成，就已经有部分绘制在电脑屏幕上。因此出现闪屏的情况。 解决办法：先将图片绘制在一个和窗口大小一致的offScreemImage上，然后再将该图片一次性画在窗口上。1234567891011121314@Overridepublic void update(Graphics g) &#123; if (offScreenImage == null) &#123; offScreenImage = this.createImage(GAME_WIDTH, GAME_HEIGHT); &#125; Graphics gOffScreen = offScreenImage.getGraphics(); Color c = gOffScreen.getColor(); gOffScreen.setColor(Color.BLACK); gOffScreen.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); gOffScreen.setColor(c); paint(gOffScreen); g.drawImage(offScreenImage, 0, 0, null);&#125; 画出了敌方坦克12345678910111213141516171819public void paint(Graphics g) &#123; switch (direction) &#123; case UP: g.drawImage(ImagesResource.badTankU, x, y, null); break; case DOWN: g.drawImage(ImagesResource.badTankD, x, y, null); break; case RIGHT: g.drawImage(ImagesResource.badTankR, x, y, null); break; case LEFT: g.drawImage(ImagesResource.badTankL, x, y, null); break; &#125; move();&#125; 增加子弹对象增加X按键，来释放子弹 为了控制子弹的发射速度，采取监听X按键抬起的信号 GameFrame类中，增加代码：123456789101112131415161718192021// 2):得到显卡的画笔public void paint(Graphics g) &#123; myTank.paint(g); if(enemyTank.isLive()) &#123; enemyTank.paint(g); &#125; if (bullets != null) &#123; for (int i = 0; i &lt; bullets.size(); i++) &#123; Bullet bullet = bullets.get(i); bullet.crashWithTank(enemyTank); if(!bullet.isLive()) &#123; bullets.remove(i); &#125;else &#123; bullet.paint(g); &#125; &#125; getBulletCount(g); &#125;&#125; 为了使子弹对象存在多个对象，将对象加入容器中子弹过多会产生内存泄漏，当子弹跑出屏幕或打到敌方坦克删除子弹对象 选择List集合框架中的ArrayList来存放子弹对象 ArrayList bullets = new ArrayList&lt;&gt;()123456789101112if (bullets != null) &#123; for (int i = 0; i &lt; bullets.size(); i++) &#123; Bullet bullet = bullets.get(i); bullet.crashWithTank(enemyTank); if(!bullet.isLive()) &#123; bullets.remove(i); &#125;else &#123; bullet.paint(g); &#125; &#125; getBulletCount(g);&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"坦克大战-第二天","slug":"坦克大战-第二天","date":"2019-07-31T00:46:58.000Z","updated":"2019-07-31T02:33:26.825Z","comments":true,"path":"2019/07/31/坦克大战-第二天/","link":"","permalink":"http://yoursite.com/2019/07/31/坦克大战-第二天/","excerpt":"","text":"坦克类的设计创建一个坦克的类 考虑坦克的属性(位置、方向、速度) 其中方向采用枚举（上、下、左、右） 加载坦克的图片 接受按键的触发，使坦克根据人的控制来动 代码实现方向枚举123Enum Direction &#123; UP, DOWN, LEFE, RIGHT&#125; 图片资源类（例如坦克图片）12345678910111213public class ImagesResource &#123; public static BufferedImage goodTankU, goodTankD, goodTankR, goodTankL; static&#123; try &#123; goodTankU = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankU.gif\")); goodTankD = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankD.gif\")); goodTankL = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankL.gif\")); goodTankR = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankR.gif\")); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 坦克类123456789101112131415161718192021222324252627282930/* 1):得到窗口传递的画笔，绘制自己 2):监听键盘按下 3):监听键盘抬起*/public class Tank &#123; private static final int SPEED = 5; // 坦克的速度 private int x, y; //坦克的初始位置 private Direction direction； // 坦克的方向 public Tank(int x, int y, Direction direction)&#123; this.x = x; this.y = y; this.direction = direction; &#125; // 1):得到窗口传递的画笔，绘制自己 public void paint (Graphics g) &#123; g.drawImage(ImagesResource.goodTankD, x, y, null); &#125; // 2):监听键盘按下 public void keyPressed(KeyEvent e) &#123; &#125; // 3):监听键盘抬起 public void keyReleased(KeyEvent e) &#123; &#125;&#125; 运行结果窗口增加键盘和窗口监听 在游戏窗口类构造器中见添加监听，并把监听信号选择性的传给坦克对象 敌方坦克不需要监听信号，自己的坦克需要。 窗口监听，来关闭程序（点击上方X，进行关闭程序） 12345678910111213141516171819202122232425262728// GameFrame的构造器增加监听public GameFrame ()&#123; . . //省略 ..... . // 键盘监听 this.addKeyListener(new KeyAdapte( @Override public void keyPressed(KeyEvent e) &#123; myTank.keyPressed(e); &#125; @Override public void keyReleased(KeyEvent e) &#123; myTank.keyReleased(e); &#125; )); // 窗口监听 this.addWindowListener(new WinodowAdapte()&#123; @Override public void windowClosing(WindowEvent e) &#123; // 关闭程序 System.exit(0); &#125; &#125;)&#125;","categories":[],"tags":[]},{"title":"坦克大战-第一天","slug":"坦克大战-第一天","date":"2019-07-30T14:19:37.000Z","updated":"2019-07-30T15:30:23.383Z","comments":true,"path":"2019/07/30/坦克大战-第一天/","link":"","permalink":"http://yoursite.com/2019/07/30/坦克大战-第一天/","excerpt":"","text":"第一天创建一个游戏窗口 新建一个GameFrame窗口类（单例设计模式） 设置游戏窗口的属性（长、宽、高、背景颜色、位置等） 给窗口一个画笔，进行绘制图形 在窗口画一个图形进行测试 将画笔交给坦克对象 1234567891011121314151617181920212223242526// 游戏的窗口/* 1):向外暴露自己的实例对象 2):得到显卡的画笔*/public class GameFrame extends Frame &#123; // 创建该类的私有化静态对象 private static final GameFrame instance = new GameFrame(); // 私有化构造器 private GameFrame()&#123; // 初始化窗口数据 this.setTitle(\"Tank War\"); // 窗口标题 this.setLocation(600, 200);// 窗口位置 this.setSize(800, 600);// 窗口大小 this.setVisible(true); // 显示窗口 &#125;; // 1):向外暴露自己的实例对象 public static GameFrame getInstance() &#123; return instance; &#125; // 2):得到显卡的画笔 public void paint(Graphics g) &#123; g.fillRect(100, 100, 50, 50); &#125;&#125; 主方法获取窗口实例对象123456public class Main &#123; public static void maiN(String[] args) &#123; // 获取窗口的实例对象 GameFrame.getInstance(); &#125;&#125; 输出结果","categories":[],"tags":[]},{"title":"坦克大战","slug":"坦克大战","date":"2019-07-30T12:31:38.000Z","updated":"2019-07-30T13:03:29.775Z","comments":true,"path":"2019/07/30/坦克大战/","link":"","permalink":"http://yoursite.com/2019/07/30/坦克大战/","excerpt":"","text":"坦克大战项目的目的 通过项目建立面向对象的设计思维，并复习OO，容器，网络、线程等基础知识 资料 1.阿里手册 2.GUI(不需要深入掌握) 项目安排 1.做一个游戏窗口并显示","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-28T08:49:02.323Z","updated":"2019-07-28T08:49:02.323Z","comments":true,"path":"2019/07/28/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}