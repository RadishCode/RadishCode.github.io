{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"MySQL基础笔记","slug":"MySQL基础笔记","date":"2019-09-21T23:34:45.000Z","updated":"2019-09-21T23:40:28.018Z","comments":true,"path":"2019/09/22/MySQL基础笔记/","link":"","permalink":"http://yoursite.com/2019/09/22/MySQL基础笔记/","excerpt":"","text":"MySQL笔记 MySQL数据库软件 安装 卸载 配置 SQL 数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB 2. 什么数据库？ * 用于存储和管理数据的仓库。 3. 数据库的特点： 1. 持久化存储数据的。其实数据库就是一个文件系统 2. 方便存储和管理数据 3. 使用了统一的方式操作数据库 -- SQL 4. 常见的数据库软件 * 参见百度MySQL数据库软件1. 安装 * 参见百度 2. 卸载 1. 去mysql的安装目录找到my.ini文件 * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; 2. 卸载MySQL 3. 删除C:/ProgramData目录下的MySQL文件夹。 3. 配置 * MySQL服务启动 1. 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql : 启动mysql的服务 * net stop mysql:关闭mysql服务 * MySQL登录 1. mysql -uroot -p密码 2. mysql -hip -uroot -p连接目标的密码 3. mysql --host=ip --user=root --password=连接目标的密码 * MySQL退出 1. exit 2. quit * MySQL目录结构 1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot; * 配置文件 my.ini 2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据SQL1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */ 3. SQL分类 1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等DDL:操作数据库、表1. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集:查询某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 2. 操作表 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名; 3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名; 4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ; 客户端图形化工具：SQLYog DML：增删改表中数据1. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。DQL：查询表中的记录* select * from 表名; 1. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表。 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略 3. 条件查询 1. where子句后跟条件 2. 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; -- 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; -- 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &apos;___&apos;; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"EL、JSTL笔记","slug":"EL、JSTL笔记","date":"2019-09-16T15:31:31.000Z","updated":"2019-09-22T00:36:57.750Z","comments":true,"path":"2019/09/16/EL、JSTL笔记/","link":"","permalink":"http://yoursite.com/2019/09/16/EL、JSTL笔记/","excerpt":"","text":"El和JSTL1. JSP: 1. 指令 2. 注释 3. 内置对象 2. MVC开发模式 3. EL表达式 4. JSTL标签 5. 三层架构JSP:1. 指令 * 作用：用于配置JSP页面，导入资源文件 * 格式： &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt; * 分类： 1. page ： 配置JSP页面的 * contentType：等同于response.setContentType() 1. 设置响应体的mime类型以及字符集 2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） * import：导包 * errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 * isErrorPage：标识当前也是是否是错误页面。 * true：是，可以使用内置对象exception * false：否。默认值。不可以使用内置对象exception 2. include ： 页面包含的。导入页面的资源文件 * &lt;%@include file=&quot;top.jsp&quot;%&gt; 3. taglib ： 导入资源 * &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; * prefix：前缀，自定义的 2. 注释: 1. html注释： &lt;!-- --&gt;:只能注释html代码片段 2. jsp注释：推荐使用 &lt;%-- --%&gt;：可以注释所有 3. 内置对象 * 在jsp页面中不需要创建，直接使用的对象 * 一共有9个： 变量名 真实类型 作用 * pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 * request HttpServletRequest 一次请求访问的多个资源(转发) * session HttpSession 一次会话的多个请求间 * application ServletContext 所有用户间共享数据 * response HttpServletResponse 响应对象 * page Object 当前页面(Servlet)的对象 this * out JspWriter 输出对象，数据输出到页面上 * config ServletConfig Servlet的配置对象 * exception Throwable 异常对象MVC：开发模式1. jsp演变历史 1. 早期只有servlet，只能使用response输出标签数据，非常麻烦 2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 2. MVC： 1. M：Model，模型。JavaBean * 完成具体的业务操作，如：查询数据库，封装对象 2. V：View，视图。JSP * 展示数据 3. C：Controller，控制器。Servlet * 获取用户的输入 * 调用模型 * 将数据交给视图进行展示 * 优缺点： 1. 优点： 1. 耦合性低，方便维护，可以利于分工协作 2. 重用性高 2. 缺点： 1. 使得项目架构变得复杂，对开发人员要求高EL表达式1. 概念：Expression Language 表达式语言 2. 作用：替换和简化jsp页面中java代码的编写 3. 语法：${表达式} 4. 注意： * jsp默认支持el表达式的。如果要忽略el表达式 1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式 2. \\${表达式} ：忽略当前这个el表达式 5. 使用： 1. 运算： * 运算符： 1. 算数运算符： + - * /(div) %(mod) 2. 比较运算符： &gt; &lt; &gt;= &lt;= == != 3. 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 4. 空运算符： empty * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 * ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 * ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 2. 获取值 1. el表达式只能从域对象中获取值 2. 语法： 1. ${域名称.键名}：从指定域中获取指定键的值 * 域名称： 1. pageScope --&gt; pageContext 2. requestScope --&gt; request 3. sessionScope --&gt; session 4. applicationScope --&gt; application（ServletContext） * 举例：在request域中存储了name=张三 * 获取：${requestScope.name} 2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 3. 获取对象、List集合、Map集合的值 1. 对象：${域名称.键名.属性名} * 本质上会去调用对象的getter方法 2. List集合：${域名称.键名[索引]} 3. Map集合： * ${域名称.键名.key名称} * ${域名称.键名[&quot;key名称&quot;]} 3. 隐式对象： * el表达式中有11个隐式对象 * pageContext： * 获取jsp其他八个内置对象 * ${pageContext.request.contextPath}：动态获取虚拟目录JSTL1. 概念：JavaServer Pages Tag Library JSP标准标签库 * 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 2. 作用：用于简化和替换jsp页面上的java代码 3. 使用步骤： 1. 导入jstl相关jar包 2. 引入标签库：taglib指令： &lt;%@ taglib %&gt; 3. 使用标签 4. 常用的JSTL标签 1. if:相当于java代码的if语句 1. 属性： * test 必须属性，接受boolean表达式 * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 * 一般情况下，test属性值会结合el表达式一起使用 2. 注意： * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 2. choose:相当于java代码的switch语句 1. 使用choose标签声明 相当于switch声明 2. 使用when标签做判断 相当于case 3. 使用otherwise标签做其他情况的声明 相当于default 3. foreach:相当于java代码的for语句 5. 练习： * 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中三层架构：软件设计架构1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互 2. 业务逻辑层：处理业务逻辑的。 3. 数据访问层：操作数据存储文件。案例：用户信息列表展示1. 需求：用户信息的增删改查操作 2. 设计： 1. 技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat 2. 数据库设计： create database day17; -- 创建数据库 use day17; -- 使用数据库 create table user( -- 创建表 id int primary key auto_increment, name varchar(20) not null, gender varchar(5), age int, address varchar(32), qq varchar(20), email varchar(50) ); 3. 开发： 1. 环境搭建 1. 创建数据库环境 2. 创建项目，导入需要的jar包 2. 编码 4. 测试 5. 部署运维","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"EL","slug":"EL","permalink":"http://yoursite.com/tags/EL/"}]},{"title":"异常和线程","slug":"异常和线程","date":"2019-09-15T09:38:21.000Z","updated":"2019-09-15T09:41:55.632Z","comments":true,"path":"2019/09/15/异常和线程/","link":"","permalink":"http://yoursite.com/2019/09/15/异常和线程/","excerpt":"","text":"目标 能够辨别程序中异常和错误的区别 说出异常的分类 说出虚拟机处理异常的方式 列举出常见的三个运行期异常 能够使用try…catch关键字处理异常 能够使用throws关键字处理异常 能够自定义异常类 能够处理自定义异常类 说出进程的概念 说出线程的概念 能够理解并发与并行的区别 能够开启新线程 第一章 异常1.1 异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.2 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。 1.3 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 1.4 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 工具类 1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println(\"num=\" + num); System.out.println(\"over\"); &#125;&#125; 上述程序执行过程图解： 第二章 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws 2.1 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException(\"要访问的arr数组不存在\");throw new ArrayIndexOutOfBoundsException(\"该索引在数组中不存在，已超出范围\"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(\"over\"); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(\"哥们，角标越界了~~~\"); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 2.2 Objects非空判断还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。 public static &lt;T&gt; T requireNonNull(T obj):查看指定引用对象不是null。 查看源码发现这里对为null的进行了抛出异常操作： 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; 2.3 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read(\"a.txt\"); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 123456789101112131415public class ThrowsDemo2 &#123; public static void main(String[] args) throws IOException &#123; read(\"a.txt\"); &#125; public static void read(String path)throws FileNotFoundException, IOException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; if (!path.equals(\"b.txt\")) &#123; throw new IOException(); &#125; &#125;&#125; 2.4 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(\"b.txt\"); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 2.4 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(\"a.txt\"); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(\"不管程序怎样，这里都将会被执行。\"); &#125; System.out.println(\"over\"); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(\"a.txt\")) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(\"文件不存在\"); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 2.5 异常注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 第三章 自定义异常3.1 概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 3.2 自定义异常的练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： 12345678910111213141516// 业务逻辑异常public class RegisterException extends Exception &#123; /** * 空参构造 */ public RegisterException() &#123; &#125; /** * * @param message 表示异常提示 */ public RegisterException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627public class Demo &#123; // 模拟数据库中已存在账号 private static String[] names = &#123;\"bill\",\"hill\",\"jill\"&#125;; public static void main(String[] args) &#123; //调用方法 try&#123; // 可能出现异常的代码 checkUsername(\"nill\"); System.out.println(\"注册成功\");//如果没有异常就是注册成功 &#125;catch(RegisterException e)&#123; //处理异常 e.printStackTrace(); &#125; &#125; //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException&#123; for (String name : names) &#123; if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常 throw new RegisterException(\"亲\"+name+\"已经被注册了！\"); &#125; &#125; return true; &#125;&#125; 第四章 多线程我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？ 要解决上述问题,咱们得使用多进程或者多线程来解决. 4.1 并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。 而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 4.2 线程与进程 进程：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程： 进程 线程 线程调度: 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 4.3 创建线程类Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来创建并启动多线程的步骤如下： 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 代码如下： 测试类： 123456789101112public class Demo01 &#123; public static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread(\"新的线程！\"); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println(\"main线程！\"+i); &#125; &#125;&#125; 自定义线程类： 12345678910111213141516public class MyThread extends Thread &#123; //定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName()+\"：正在执行！\"+i); &#125; &#125;&#125;","categories":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/categories/javase/"}],"tags":[{"name":"javase","slug":"javase","permalink":"http://yoursite.com/tags/javase/"}]},{"title":"redis笔记","slug":"redis笔记","date":"2019-09-12T11:02:43.000Z","updated":"2019-09-12T11:06:24.270Z","comments":true,"path":"2019/09/12/redis笔记/","link":"","permalink":"http://yoursite.com/2019/09/12/redis笔记/","excerpt":"","text":"Redis1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库 1.1.什么是NOSQL NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 1.1.1. NOSQL和关系型数据库比较 优点： 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 3）不提供关系型数据库对事务的处理。 1.1.2. 非关系型数据库的优势： 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 1.1.3. 关系型数据库的优势： 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 1.1.4. 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品 • 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 • 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 • 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 • 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 1) 字符串类型 string 2) 哈希类型 hash 3) 列表类型 list 4) 集合类型 set 5) 有序集合类型 sortedset 1.3.1 redis的应用场景 • 缓存（数据查询、短连接、新闻内容、商品内容等等） • 聊天室的在线好友列表 • 任务队列。（秒杀、抢购、12306等等） • 应用排行榜 • 网站访问统计 • 数据过期处理（可以精确到毫秒 • 分布式集群架构中的session分离 2. 下载安装 1. 官网：https://redis.io 2. 中文网：http://www.redis.net.cn/ 3. 解压直接可以使用： * redis.windows.conf：配置文件 * redis-cli.exe：redis的客户端 * redis-server.exe：redis服务器端 3. 命令操作 1. redis的数据结构： * redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 * value的数据结构： 1) 字符串类型 string 2) 哈希类型 hash ： map格式 3) 列表类型 list ： linkedlist格式。支持重复元素 4) 集合类型 set ： 不允许重复元素 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 2. 字符串类型 string 1. 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 3. 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 3. 哈希类型 hash 1. 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 2. 获取： * hget key field: 获取指定的field对应的值 127.0.0.1:6379&gt; hget myhash username &quot;lisi&quot; * hgetall key：获取所有的field和value 127.0.0.1:6379&gt; hgetall myhash 1) &quot;username&quot; 2) &quot;lisi&quot; 3) &quot;password&quot; 4) &quot;123&quot; 3. 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： 1. lpush key value: 将元素加入列表左表 2. rpush key value：将元素加入列表右边 127.0.0.1:6379&gt; lpush myList a (integer) 1 127.0.0.1:6379&gt; lpush myList b (integer) 2 127.0.0.1:6379&gt; rpush myList c (integer) 3 2. 获取： * lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 1) &quot;b&quot; 2) &quot;a&quot; 3) &quot;c&quot; 3. 删除： * lpop key： 删除列表最左边的元素，并将元素返回 * rpop key： 删除列表最右边的元素，并将元素返回 5. 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 1. 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 2. 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 3. 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 7. 通用命令 1. keys * : 查询所有的键 2. type key ： 获取键对应的value的类型 3. del key：删除指定的key value 4. 持久化 1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 2. redis持久化机制： 1. RDB：默认方式，不需要进行配置，默认就使用这种机制 * 在一定的间隔时间中，检测key的变化情况，然后持久化数据 1. 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 2. 重新启动redis服务器，并指定配置文件名称 D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf 2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 1. 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 5. Java客户端 Jedis * Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接 jedis.close(); * Jedis操作各种redis中的数据结构 1) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 //存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //获取 String username = jedis.get(&quot;username&quot;); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); } //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); } /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } }案例：案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 * 注意：使用redis缓存一些不经常发生变化的数据。 * 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"Ajax和Json","slug":"Ajax和Json","date":"2019-09-10T01:57:56.000Z","updated":"2019-09-10T02:00:40.846Z","comments":true,"path":"2019/09/10/Ajax和Json/","link":"","permalink":"http://yoursite.com/2019/09/10/Ajax和Json/","excerpt":"","text":"AJAX和JSON1. AJAX： 2. JSONAJAX：1. 概念： ASynchronous JavaScript And XML 异步的JavaScript 和 XML 1. 异步和同步：客户端和服务器端相互通信的基础上 * 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 * 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 提升用户的体验 2. 实现方式： 1. 原生的JS实现方式（了解） //1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); } else {// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } //2. 建立连接 /* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */ xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true); //3.发送请求 xmlhttp.send(); //4.接受并处理来自服务器的响应结果 //获取方式 ：xmlhttp.responseText //什么时候获取？当服务器响应成功后再获取 //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。 xmlhttp.onreadystatechange=function() { //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); } } 2. JQeury实现方式 1. $.ajax() * 语法：$.ajax({键值对}); //使用$.ajax()发送异步请求 $.ajax({ url:&quot;ajaxServlet1111&quot; , // 请求路径 type:&quot;POST&quot; , //请求方式 //data: &quot;username=jack&amp;age=23&quot;,//请求参数 data:{&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23}, success:function (data) { alert(data); },//响应成功后的回调函数 error:function () { alert(&quot;出错啦...&quot;) },//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 }); 2. $.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 3. $.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型JSON：1. 概念： JavaScript Object Notation JavaScript对象表示法 Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); var p = {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;}; * json现在多用于存储和交换文本信息的语法 * 进行数据的传输 * JSON 比 XML 更小、更快，更易解析。 2. 语法： 1. 基本规则 * 数据在名称/值对中：json数据是由键值对构成的 * 键用引号(单双都行)引起来，也可以不使用引号 * 值得取值类型： 1. 数字（整数或浮点数） 2. 字符串（在双引号中） 3. 逻辑值（true 或 false） 4. 数组（在方括号中） {&quot;persons&quot;:[{},{}]} 5. 对象（在花括号中） {&quot;address&quot;:{&quot;province&quot;：&quot;陕西&quot;....}} 6. null * 数据由逗号分隔：多个键值对由逗号分隔 * 花括号保存对象：使用{}定义json 格式 * 方括号保存数组：[] 2. 获取数据: 1. json对象.键名 2. json对象[&quot;键名&quot;] 3. 数组对象[索引] 4. 遍历 //1.定义基本格式 var person = {&quot;name&quot;: &quot;张三&quot;, age: 23, &apos;gender&apos;: true}; var ps = [{&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true}, {&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true}, {&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false}]; //获取person对象中所有的键和值 //for in 循环 /* for(var key in person){ //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]); }*/ //获取ps中的所有值 for (var i = 0; i &lt; ps.length; i++) { var p = ps[i]; for(var key in p){ alert(key+&quot;:&quot;+p[key]); } } 3. JSON数据和Java对象的相互转换 * JSON解析器： * 常见的解析器：Jsonlib，Gson，fastjson，jackson 1. JSON转为Java对象 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. readValue(json字符串数据,Class) 2. Java对象转换JSON 1. 使用步骤： 1. 导入jackson的相关jar包 2. 创建Jackson核心对象 ObjectMapper 3. 调用ObjectMapper的相关方法进行转换 1. 转换方法： * writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 * writeValueAsString(obj):将对象转为json字符串 2. 注解： 1. @JsonIgnore：排除属性。 2. @JsonFormat：属性值得格式化 * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) 3. 复杂java对象转换 1. List：数组 2. Map：对象格式一致案例：* 校验用户名是否存在 1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案： 1. $.get(type):将最后一个参数type指定为&quot;json&quot; 2. 在服务器端设置MIME类型 response.setContentType(&quot;application/json;charset=utf-8&quot;);","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Ajax,Json","slug":"Ajax-Json","permalink":"http://yoursite.com/tags/Ajax-Json/"}]},{"title":"JQuery高级笔记","slug":"JQuery高级笔记","date":"2019-09-10T01:52:52.000Z","updated":"2019-09-10T01:55:15.208Z","comments":true,"path":"2019/09/10/JQuery高级笔记/","link":"","permalink":"http://yoursite.com/2019/09/10/JQuery高级笔记/","excerpt":"","text":"JQuery高级1. JQuery 高级 1. 动画 2. 遍历 3. 事件绑定 4. 案例 5. 插件JQuery 高级1. 动画 1. 三种方式显示和隐藏元素 1. 默认显示和隐藏方式 1. show([speed,[easing],[fn]]) 1. 参数： 1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) 2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot; * swing：动画执行时效果是 先慢，中间快，最后又慢 * linear：动画执行时速度是匀速的 3. fn：在动画完成时执行的函数，每个元素执行一次。 2. hide([speed,[easing],[fn]]) 3. toggle([speed],[easing],[fn]) 2. 滑动显示和隐藏方式 1. slideDown([speed],[easing],[fn]) 2. slideUp([speed,[easing],[fn]]) 3. slideToggle([speed],[easing],[fn]) 3. 淡入淡出显示和隐藏方式 1. fadeIn([speed],[easing],[fn]) 2. fadeOut([speed],[easing],[fn]) 3. fadeToggle([speed,[easing],[fn]]) 2. 遍历 1. js的遍历方式 * for(初始化值;循环结束条件;步长) 2. jq的遍历方式 1. jq对象.each(callback) 1. 语法： jquery对象.each(function(index,element){}); * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 2. 回调函数返回值： * true:如果当前function返回为false，则结束循环(break)。 * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) 2. $.each(object, [callback]) 3. for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 3. 事件绑定 1. jquery标准的绑定方式 * jq对象.事件方法(回调函数)； * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 * 表单对象.submit();//让表单提交 2. on绑定事件/off解除绑定 * jq对象.on(&quot;事件名称&quot;,回调函数) * jq对象.off(&quot;事件名称&quot;) * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 3. 事件切换：toggle * jq对象.toggle(fn1,fn2...) * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2..... * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 4. 案例 1. 广告显示和隐藏 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt; &lt;style&gt; #content{width:100%;height:500px;background:#999} &lt;/style&gt; &lt;!--引入jquery--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 需求： 1. 当页面加载完，3秒后。自动显示广告 2. 广告显示5秒后，自动消失。 分析： 1. 使用定时器来完成。setTimeout (执行一次定时器) 2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display 3. 使用 show/hide方法来完成广告的显示 */ //入口函数，在页面加载完成之后，定义定时器，调用这两个方法 $(function () { //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); }); //显示广告 function adShow() { //获取广告div，调用显示方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); } //隐藏广告 function adHide() { //获取广告div，调用隐藏方法 $(&quot;#ad&quot;).hide(&quot;slow&quot;); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 整体的DIV --&gt; &lt;div&gt; &lt;!-- 广告DIV --&gt; &lt;div id=&quot;ad&quot; style=&quot;display: none;&quot;&gt; &lt;img style=&quot;width:100%&quot; src=&quot;../img/adv.jpg&quot; /&gt; &lt;/div&gt; &lt;!-- 下方正文部分 --&gt; &lt;div id=&quot;content&quot;&gt; 正文部分 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2. 抽奖 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jquery案例之抽奖&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script language=&apos;javascript&apos; type=&apos;text/javascript&apos;&gt; /* 分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 * 定义数组，存放图片资源路径 * 生成随机数。数组索引 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 */ var imgs = [&quot;../img/man00.jpg&quot;, &quot;../img/man01.jpg&quot;, &quot;../img/man02.jpg&quot;, &quot;../img/man03.jpg&quot;, &quot;../img/man04.jpg&quot;, &quot;../img/man05.jpg&quot;, &quot;../img/man06.jpg&quot;, ]; var startId;//开始定时器的id var index;//随机角标 $(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); //1. 给开始按钮绑定单击事件 $(&quot;#startID&quot;).click(function () { // 1.1 定义循环定时器 20毫秒执行一次 startId = setInterval(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false); //1.2生成随机角标 0-6 index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999 //1.3设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); },20); }); //2. 给结束按钮绑定单击事件 $(&quot;#stopID&quot;).click(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); // 1.1 停止定时器 clearInterval(startId); // 1.2 给大相框设置src属性 $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide(); //显示1秒之后 $(&quot;#img2ID&quot;).show(1000); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 小像框 --&gt; &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt; &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt; &lt;/div&gt; &lt;!-- 大像框 --&gt; &lt;div style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt; &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt; &lt;/div&gt; &lt;!-- 开始按钮 --&gt; &lt;input id=&quot;startID&quot; type=&quot;button&quot; value=&quot;点击开始&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;!-- 停止按钮 --&gt; &lt;input id=&quot;stopID&quot; type=&quot;button&quot; value=&quot;点击停止&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;/body&gt; &lt;/html&gt; 5. 插件：增强JQuery的功能 1. 实现方式： 1. $.fn.extend(object) * 增强通过Jquery获取的对象的功能 $(&quot;#id&quot;) 2. $.extend(object) * 增强JQeury对象自身的功能 $/jQuery","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"JQuery基础笔记","slug":"JQuery基础笔记","date":"2019-09-07T11:19:56.000Z","updated":"2019-09-07T11:21:05.111Z","comments":true,"path":"2019/09/07/JQuery基础笔记/","link":"","permalink":"http://yoursite.com/2019/09/07/JQuery基础笔记/","excerpt":"","text":"知识点： JQuery 基础：1. 概念 2. 快速入门 3. JQuery对象和JS对象区别与转换 4. 选择器 5. DOM操作 6. 案例 JQuery 基础：1. 概念： 一个JavaScript框架。简化JS开发 * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 2. 快速入门 1. 步骤： 1. 下载JQuery * 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日) 2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求， 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） * jquery-xxx.js 与 jquery-xxx.min.js区别： 1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 2. 导入JQuery的js文件：导入min.js文件 3. 使用 var div1 = $(&quot;#div1&quot;); alert(div1.html()); 3. JQuery对象和JS对象区别与转换 1. JQuery对象在操作时，更加方便。 2. JQuery对象和js对象方法不通用的. 3. 两者相互转换 * jq -- &gt; js : jq对象[索引] 或者 jq对象.get(索引) * js -- &gt; jq : $(js对象) 4. 选择器：筛选具有相似特征的元素(标签) 1. 基本操作学习： 1. 事件绑定 //1.获取b1按钮 $(&quot;#b1&quot;).click(function(){ alert(&quot;abc&quot;); }); 2. 入口函数 $(function () { }); window.onload 和 $(function) 区别 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 * $(function)可以定义多次的。 3. 样式控制：css方法 // $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;); $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); 2. 分类 1. 基本选择器 1. 标签选择器（元素选择器） * 语法： $(&quot;html标签名&quot;) 获得所有匹配标签名称的元素 2. id选择器 * 语法： $(&quot;#id的属性值&quot;) 获得与指定id属性值匹配的元素 3. 类选择器 * 语法： $(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素 4. 并集选择器： * 语法： $(&quot;选择器1,选择器2....&quot;) 获取多个选择器选中的所有元素 2. 层级选择器 1. 后代选择器 * 语法： $(&quot;A B &quot;) 选择A元素内部的所有B元素 2. 子选择器 * 语法： $(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 3. 属性选择器 1. 属性名称选择器 * 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器 2. 属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器 3. 复合属性选择器 * 语法： $(&quot;A[属性名=&apos;值&apos;][]...&quot;) 包含多个属性条件的选择器 4. 过滤选择器 1. 首元素选择器 * 语法： :first 获得选择的元素中的第一个元素 2. 尾元素选择器 * 语法： :last 获得选择的元素中的最后一个元素 3. 非元素选择器 * 语法： :not(selector) 不包括指定内容的元素 4. 偶数选择器 * 语法： :even 偶数，从 0 开始计数 5. 奇数选择器 * 语法： :odd 奇数，从 0 开始计数 6. 等于索引选择器 * 语法： :eq(index) 指定索引元素 7. 大于索引选择器 * 语法： :gt(index) 大于指定索引元素 8. 小于索引选择器 * 语法： :lt(index) 小于指定索引元素 9. 标题选择器 * 语法： :header 获得标题（h1~h6）元素，固定写法 5. 表单过滤选择器 1. 可用元素选择器 * 语法： :enabled 获得可用元素 2. 不可用元素选择器 * 语法： :disabled 获得不可用元素 3. 选中选择器 * 语法： :checked 获得单选/复选框选中的元素 4. 选中选择器 * 语法： :selected 获得下拉框选中的元素 5. DOM操作 1. 内容操作 1. html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; 2. text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 3. val()： 获取/设置元素的value属性值 2. 属性操作 1. 通用属性操作 1. attr(): 获取/设置元素的属性 2. removeAttr():删除属性 3. prop():获取/设置元素的属性 4. removeProp():删除属性 * attr和prop区别？ 1. 如果操作的是元素的固有属性，则建议使用prop 2. 如果操作的是元素自定义的属性，则建议使用attr 2. 对class属性操作 1. addClass():添加class属性值 2. removeClass():删除class属性值 3. toggleClass():切换class属性 * toggleClass(&quot;one&quot;): * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。 如果元素对象上不存在class=&quot;one&quot;，则添加 4. css(): 3. CRUD操作: 1. append():父元素将子元素追加到末尾 * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 2. prepend():父元素将子元素追加到开头 * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 3. appendTo(): * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 4. prependTo()： * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 5. after():添加元素到元素后边 * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 6. before():添加元素到元素前边 * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 7. insertAfter() * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 8. insertBefore() * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 9. remove():移除元素 * 对象.remove():将对象删除掉 10. empty():清空元素的所有后代元素。 * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"web数据库乱码编码","slug":"web数据库乱码编码","date":"2019-08-30T13:43:53.000Z","updated":"2019-08-30T14:05:59.021Z","comments":true,"path":"2019/08/30/web数据库乱码编码/","link":"","permalink":"http://yoursite.com/2019/08/30/web数据库乱码编码/","excerpt":"","text":"web文本中的乱码问题问题简介： 从数据库获取学生数据时，中文不会出现乱码。但是当增加数据的时候，会出现乱码。乱码全为？？？ 自我思考： 中文乱码和但是英文，数学不会出现乱码。很大程度是字符集的编码问题。 但是特殊的是：从数据库获取数据不会乱码。当web上增加数据时，就会出现乱码 检查jsp, java， 数据库表的编码格式都是“utf-8”，这就很难受 最后想到应该是数据库的问题，想到安装时。数据库默认的字符集时latin1,并没有修改 于是修改一下，进行测试 修改字符集 1. 2. 问题最后解决了","categories":[],"tags":[{"name":"编码问题","slug":"编码问题","permalink":"http://yoursite.com/tags/编码问题/"}]},{"title":"NoClassDefFounfError","slug":"NoClassDefFounfError","date":"2019-08-28T13:35:49.000Z","updated":"2019-08-28T14:11:25.039Z","comments":true,"path":"2019/08/28/NoClassDefFounfError/","link":"","permalink":"http://yoursite.com/2019/08/28/NoClassDefFounfError/","excerpt":"","text":"问题简介出现 在开发一个登陆界面的web项目时，需要用户输入的账号和密码和数据存储的账号和密码做对比，来判断用户和密码是否正确。因此使用到了Druid连接池jar包 写好了，数据库连接池的工具类，在单元测试中可以正确的运行，但是在web上运行是就会报错 提示错误 问题解决数据库连接池jar路径问题修改前：修改后：","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"css代码不恰当提示解决","slug":"css代码不恰当提示解决","date":"2019-08-22T23:58:33.000Z","updated":"2019-08-23T00:35:08.000Z","comments":true,"path":"2019/08/23/css代码不恰当提示解决/","link":"","permalink":"http://yoursite.com/2019/08/23/css代码不恰当提示解决/","excerpt":"","text":"css设置web背景图遇见的问题问题 提示信息 解释检查发现相似的css内容，它能被简化形式 问题解决修改代码后：","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"解决banner居中显示问题","slug":"解决banner居中显示问题","date":"2019-08-14T12:49:11.000Z","updated":"2019-08-14T12:50:53.426Z","comments":true,"path":"2019/08/14/解决banner居中显示问题/","link":"","permalink":"http://yoursite.com/2019/08/14/解决banner居中显示问题/","excerpt":"","text":"地址： https://www.cnblogs.com/chenchenhao/p/9889628.html 在做web界面时，出现了窗口缩放时，banner图片布局中的问题，在博客园找到了解决方法 大家在做项目的时候有没有遇到一个问题呢 就是一张图片宽度100% 在缩放屏幕的时候图片会被压缩变形！！！那么怎么才能实现图片始终居中而不被压缩变形呢？ 接下来让我带领大家解决这个问题 请看代码↓↓↓↓↓↓↓1234567891011121314151617181920212223242526272829303132&lt;style&gt; .bannerbox &#123; width: 100%; position: relative; overflow: hidden; height: 500px; border: 1px solid red; &#125; .banner &#123; width: 1920px; /*图片宽度*/ position: absolute; left: 50%; margin-left: -960px; /*图片宽度的一半*/ &#125; &lt;/style&gt; &lt;div class='bannerbox'&gt; &lt;div class='banner'&gt; &lt;img src=\"./banner.png\"&gt; &lt;/div&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"网页轮播图","slug":"网页轮播图","date":"2019-08-09T12:29:06.000Z","updated":"2019-08-09T12:44:28.305Z","comments":true,"path":"2019/08/09/网页轮播图/","link":"","permalink":"http://yoursite.com/2019/08/09/网页轮播图/","excerpt":"","text":"网页页面的轮播图 1.setInterval(fun, time) fun为函数，time为毫秒 2.使用document.getElementById()来获取body里的对象 如：var img = document.getElementById() 3.使用数组来存储图片的路径123456789101112131415161718192021222324252627&lt;body&gt; &lt;img src=\"./images/1.jpg\" id = \"pic\"&gt; &lt;script&gt; var imgArr = new Array(0); imgArr.push(\"./images/1.jpg\"); imgArr.push(\"./images/4.jpg\"); imgArr.push(\"./images/off.jpg\"); imgArr.push(\"./images/on.jpg\"); var img = document.getElementById(\"pic\"); setInterval(slide, 1000); var index = 0; function slide()&#123; if(index == imgArr.length - 1)&#123; img.src = imgArr[index]; index -= imgArr.length - 1; &#125; else &#123; img.src = imgArr[index]; index += 1; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 代码实现","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"html背景图自适应","slug":"html背景图自适应","date":"2019-08-08T11:05:33.000Z","updated":"2019-08-08T11:13:31.246Z","comments":true,"path":"2019/08/08/html背景图自适应/","link":"","permalink":"http://yoursite.com/2019/08/08/html背景图自适应/","excerpt":"","text":"账号注册页面设计出现问题网页背景图片不能根据浏览器的变大而变大,会出现空白区12345body&#123; background:url('./测试图片/1.jpeg'); background-repeat:no-repeat; background-size:100% 100%&#125;","categories":[],"tags":[{"name":"hmtl","slug":"hmtl","permalink":"http://yoursite.com/tags/hmtl/"}]},{"title":"坦克大战-第四天","slug":"坦克大战-第四天","date":"2019-08-04T13:39:25.000Z","updated":"2019-08-05T02:49:53.348Z","comments":true,"path":"2019/08/04/坦克大战-第四天/","link":"","permalink":"http://yoursite.com/2019/08/04/坦克大战-第四天/","excerpt":"","text":"敌方坦克 1.增加了敌方坦克的随机运动和随机发射子弹,使用了Random类 2.在游戏窗口类中,新增一个成员变量为List enemyTanks = new Arraylist&lt;&gt;(),用于存放多个敌方坦克对象 3.增加了坦克越界的边界检查,如果坦克的位置出界就把位置赋值为老的位置 123456789// 在Direction枚举对象中,增加随机方向的方法public enum Direction &#123; UP, DOWN, LEFT, RIGHT; private static Random rand = new Random(); public static Direction randomDir() &#123; return values()[rand.nextInt(values().length)]; &#125;&#125; 在敌方坦克类(Tank)中加入随机方法的方法 123456private Random rand = New Random();private void setDirection() &#123; if(rand.nextInt(100) &gt; 95)&#123; // 当随机数大于95时再随机设置方式 this.direction = Direction.randomDir(); &#125;&#125; 在游戏窗口类中增加List 1234// 存放敌方坦克对象List&lt;Tank&gt; enemyTanks = new ArrayList&lt;&gt;();// 监听键盘的Y按键, 当按键Y抬起时// add(new Tank(200, 200 , Direction.randomDir, ,Group.Bad)); 增加边界检测 当坦克出界是, 使上步位置赋值给现在的位置, 在进行绘制坦克123456789101112131415161718192021222324252627282930private void boundsCheck() &#123; if(x &lt; 0 || y &lt; 30 || x + this.WIDTH &gt; gf.GAME_WIDTH || y + this.HEIGHT &gt; gf.GAME_HEIGHT) &#123; this.x =this.oldX; this.y = this.oldY; &#125;&#125;// 将此方法加入坦克类的move()方法的最下方// 5):根据方向一直移动private void move() &#123; this.oldX = x; this.oldY = y; setDirection(); switch (direction) &#123; case UP: y -= SPEED; break; case DOWN: y += SPEED; break; case RIGHT: x += SPEED; break; case LEFT: x -= SPEED; break; &#125; boundsCheck(); fire();&#125; 随机时刻发出子弹也是使用Random的对象, 和设置方向的方式一样。上方代码已经创建了Random的对象，因此直接使用rand调用nextInt()方法即可 123456789// 此方法加入move()方法的下方private void fire() &#123; if(rand.nextInt(100) &gt; 95) &#123; if(gf == null)&#123; gf = GameFrame.getInstance; &#125; gf.add(new Bullet(x, y, direction, group)); &#125;&#125; 程序运行结果:","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"坦克大战-第三天","slug":"坦克大战-第三天","date":"2019-08-02T07:43:02.000Z","updated":"2019-08-02T08:49:36.088Z","comments":true,"path":"2019/08/02/坦克大战-第三天/","link":"","permalink":"http://yoursite.com/2019/08/02/坦克大战-第三天/","excerpt":"","text":"主要内容增加了按键控制坦克的方向 监听键盘上下左右按键，进行控制坦克的运行123456789101112131415161718192021222324252627282930313233343536373839404142// 4):设置坦克方向private void setDirection() &#123; if (!isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; !isD) &#123; isMoving = false; &#125; else &#123; isMoving = true; &#125; if (isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; !isD) &#123; direction = Direction.UP; &#125; if (!isU &amp;&amp; isR &amp;&amp; !isL &amp;&amp; !isD) &#123; direction = Direction.RIGHT; &#125; if (!isU &amp;&amp; !isR &amp;&amp; isL &amp;&amp; !isD) &#123; direction = Direction.LEFT; &#125; if (!isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; isD) &#123; direction = Direction.DOWN; &#125;&#125;// 5):根据方向一直移动private void move() &#123; if (!isMoving) &#123; return; &#125; switch (direction) &#123; case UP: y -= SPEED; break; case DOWN: y += SPEED; break; case RIGHT: x += SPEED; break; case LEFT: x -= SPEED; break; &#125;&#125; 解决游戏坦克图片闪动严重原因： 由于每次画图需要从内存中读取数据，在一点一点的绘制在窗口上。一边读取一边绘制。读取还为完成，就已经有部分绘制在电脑屏幕上。因此出现闪屏的情况。 解决办法：先将图片绘制在一个和窗口大小一致的offScreemImage上，然后再将该图片一次性画在窗口上。1234567891011121314@Overridepublic void update(Graphics g) &#123; if (offScreenImage == null) &#123; offScreenImage = this.createImage(GAME_WIDTH, GAME_HEIGHT); &#125; Graphics gOffScreen = offScreenImage.getGraphics(); Color c = gOffScreen.getColor(); gOffScreen.setColor(Color.BLACK); gOffScreen.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); gOffScreen.setColor(c); paint(gOffScreen); g.drawImage(offScreenImage, 0, 0, null);&#125; 画出了敌方坦克12345678910111213141516171819public void paint(Graphics g) &#123; switch (direction) &#123; case UP: g.drawImage(ImagesResource.badTankU, x, y, null); break; case DOWN: g.drawImage(ImagesResource.badTankD, x, y, null); break; case RIGHT: g.drawImage(ImagesResource.badTankR, x, y, null); break; case LEFT: g.drawImage(ImagesResource.badTankL, x, y, null); break; &#125; move();&#125; 增加子弹对象增加X按键，来释放子弹 为了控制子弹的发射速度，采取监听X按键抬起的信号 GameFrame类中，增加代码：123456789101112131415161718192021// 2):得到显卡的画笔public void paint(Graphics g) &#123; myTank.paint(g); if(enemyTank.isLive()) &#123; enemyTank.paint(g); &#125; if (bullets != null) &#123; for (int i = 0; i &lt; bullets.size(); i++) &#123; Bullet bullet = bullets.get(i); bullet.crashWithTank(enemyTank); if(!bullet.isLive()) &#123; bullets.remove(i); &#125;else &#123; bullet.paint(g); &#125; &#125; getBulletCount(g); &#125;&#125; 为了使子弹对象存在多个对象，将对象加入容器中子弹过多会产生内存泄漏，当子弹跑出屏幕或打到敌方坦克删除子弹对象 选择List集合框架中的ArrayList来存放子弹对象 ArrayList bullets = new ArrayList&lt;&gt;()123456789101112if (bullets != null) &#123; for (int i = 0; i &lt; bullets.size(); i++) &#123; Bullet bullet = bullets.get(i); bullet.crashWithTank(enemyTank); if(!bullet.isLive()) &#123; bullets.remove(i); &#125;else &#123; bullet.paint(g); &#125; &#125; getBulletCount(g);&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"坦克大战-第二天","slug":"坦克大战-第二天","date":"2019-07-31T00:46:58.000Z","updated":"2019-07-31T02:33:26.825Z","comments":true,"path":"2019/07/31/坦克大战-第二天/","link":"","permalink":"http://yoursite.com/2019/07/31/坦克大战-第二天/","excerpt":"","text":"坦克类的设计创建一个坦克的类 考虑坦克的属性(位置、方向、速度) 其中方向采用枚举（上、下、左、右） 加载坦克的图片 接受按键的触发，使坦克根据人的控制来动 代码实现方向枚举123Enum Direction &#123; UP, DOWN, LEFE, RIGHT&#125; 图片资源类（例如坦克图片）12345678910111213public class ImagesResource &#123; public static BufferedImage goodTankU, goodTankD, goodTankR, goodTankL; static&#123; try &#123; goodTankU = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankU.gif\")); goodTankD = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankD.gif\")); goodTankL = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankL.gif\")); goodTankR = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankR.gif\")); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 坦克类123456789101112131415161718192021222324252627282930/* 1):得到窗口传递的画笔，绘制自己 2):监听键盘按下 3):监听键盘抬起*/public class Tank &#123; private static final int SPEED = 5; // 坦克的速度 private int x, y; //坦克的初始位置 private Direction direction； // 坦克的方向 public Tank(int x, int y, Direction direction)&#123; this.x = x; this.y = y; this.direction = direction; &#125; // 1):得到窗口传递的画笔，绘制自己 public void paint (Graphics g) &#123; g.drawImage(ImagesResource.goodTankD, x, y, null); &#125; // 2):监听键盘按下 public void keyPressed(KeyEvent e) &#123; &#125; // 3):监听键盘抬起 public void keyReleased(KeyEvent e) &#123; &#125;&#125; 运行结果窗口增加键盘和窗口监听 在游戏窗口类构造器中见添加监听，并把监听信号选择性的传给坦克对象 敌方坦克不需要监听信号，自己的坦克需要。 窗口监听，来关闭程序（点击上方X，进行关闭程序） 12345678910111213141516171819202122232425262728// GameFrame的构造器增加监听public GameFrame ()&#123; . . //省略 ..... . // 键盘监听 this.addKeyListener(new KeyAdapte( @Override public void keyPressed(KeyEvent e) &#123; myTank.keyPressed(e); &#125; @Override public void keyReleased(KeyEvent e) &#123; myTank.keyReleased(e); &#125; )); // 窗口监听 this.addWindowListener(new WinodowAdapte()&#123; @Override public void windowClosing(WindowEvent e) &#123; // 关闭程序 System.exit(0); &#125; &#125;)&#125;","categories":[],"tags":[]},{"title":"坦克大战-第一天","slug":"坦克大战-第一天","date":"2019-07-30T14:19:37.000Z","updated":"2019-07-30T15:30:23.383Z","comments":true,"path":"2019/07/30/坦克大战-第一天/","link":"","permalink":"http://yoursite.com/2019/07/30/坦克大战-第一天/","excerpt":"","text":"第一天创建一个游戏窗口 新建一个GameFrame窗口类（单例设计模式） 设置游戏窗口的属性（长、宽、高、背景颜色、位置等） 给窗口一个画笔，进行绘制图形 在窗口画一个图形进行测试 将画笔交给坦克对象 1234567891011121314151617181920212223242526// 游戏的窗口/* 1):向外暴露自己的实例对象 2):得到显卡的画笔*/public class GameFrame extends Frame &#123; // 创建该类的私有化静态对象 private static final GameFrame instance = new GameFrame(); // 私有化构造器 private GameFrame()&#123; // 初始化窗口数据 this.setTitle(\"Tank War\"); // 窗口标题 this.setLocation(600, 200);// 窗口位置 this.setSize(800, 600);// 窗口大小 this.setVisible(true); // 显示窗口 &#125;; // 1):向外暴露自己的实例对象 public static GameFrame getInstance() &#123; return instance; &#125; // 2):得到显卡的画笔 public void paint(Graphics g) &#123; g.fillRect(100, 100, 50, 50); &#125;&#125; 主方法获取窗口实例对象123456public class Main &#123; public static void maiN(String[] args) &#123; // 获取窗口的实例对象 GameFrame.getInstance(); &#125;&#125; 输出结果","categories":[],"tags":[]},{"title":"坦克大战","slug":"坦克大战","date":"2019-07-30T12:31:38.000Z","updated":"2019-07-30T13:03:29.775Z","comments":true,"path":"2019/07/30/坦克大战/","link":"","permalink":"http://yoursite.com/2019/07/30/坦克大战/","excerpt":"","text":"坦克大战项目的目的 通过项目建立面向对象的设计思维，并复习OO，容器，网络、线程等基础知识 资料 1.阿里手册 2.GUI(不需要深入掌握) 项目安排 1.做一个游戏窗口并显示","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]}]}