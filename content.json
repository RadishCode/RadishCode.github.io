{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"NoClassDefFounfError","slug":"NoClassDefFounfError","date":"2019-08-28T13:35:49.000Z","updated":"2019-08-28T14:11:25.039Z","comments":true,"path":"2019/08/28/NoClassDefFounfError/","link":"","permalink":"http://yoursite.com/2019/08/28/NoClassDefFounfError/","excerpt":"","text":"问题简介出现 在开发一个登陆界面的web项目时，需要用户输入的账号和密码和数据存储的账号和密码做对比，来判断用户和密码是否正确。因此使用到了Druid连接池jar包 写好了，数据库连接池的工具类，在单元测试中可以正确的运行，但是在web上运行是就会报错 提示错误 问题解决数据库连接池jar路径问题修改前：修改后：","categories":[],"tags":[{"name":"web","slug":"web","permalink":"http://yoursite.com/tags/web/"}]},{"title":"css代码不恰当提示解决","slug":"css代码不恰当提示解决","date":"2019-08-22T23:58:33.000Z","updated":"2019-08-23T00:35:08.000Z","comments":true,"path":"2019/08/23/css代码不恰当提示解决/","link":"","permalink":"http://yoursite.com/2019/08/23/css代码不恰当提示解决/","excerpt":"","text":"css设置web背景图遇见的问题问题 提示信息 解释检查发现相似的css内容，它能被简化形式 问题解决修改代码后：","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"解决banner居中显示问题","slug":"解决banner居中显示问题","date":"2019-08-14T12:49:11.000Z","updated":"2019-08-14T12:50:53.426Z","comments":true,"path":"2019/08/14/解决banner居中显示问题/","link":"","permalink":"http://yoursite.com/2019/08/14/解决banner居中显示问题/","excerpt":"","text":"地址： https://www.cnblogs.com/chenchenhao/p/9889628.html 在做web界面时，出现了窗口缩放时，banner图片布局中的问题，在博客园找到了解决方法 大家在做项目的时候有没有遇到一个问题呢 就是一张图片宽度100% 在缩放屏幕的时候图片会被压缩变形！！！那么怎么才能实现图片始终居中而不被压缩变形呢？ 接下来让我带领大家解决这个问题 请看代码↓↓↓↓↓↓↓1234567891011121314151617181920212223242526272829303132&lt;style&gt; .bannerbox &#123; width: 100%; position: relative; overflow: hidden; height: 500px; border: 1px solid red; &#125; .banner &#123; width: 1920px; /*图片宽度*/ position: absolute; left: 50%; margin-left: -960px; /*图片宽度的一半*/ &#125; &lt;/style&gt; &lt;div class='bannerbox'&gt; &lt;div class='banner'&gt; &lt;img src=\"./banner.png\"&gt; &lt;/div&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"网页轮播图","slug":"网页轮播图","date":"2019-08-09T12:29:06.000Z","updated":"2019-08-09T12:44:28.305Z","comments":true,"path":"2019/08/09/网页轮播图/","link":"","permalink":"http://yoursite.com/2019/08/09/网页轮播图/","excerpt":"","text":"网页页面的轮播图 1.setInterval(fun, time) fun为函数，time为毫秒 2.使用document.getElementById()来获取body里的对象 如：var img = document.getElementById() 3.使用数组来存储图片的路径123456789101112131415161718192021222324252627&lt;body&gt; &lt;img src=\"./images/1.jpg\" id = \"pic\"&gt; &lt;script&gt; var imgArr = new Array(0); imgArr.push(\"./images/1.jpg\"); imgArr.push(\"./images/4.jpg\"); imgArr.push(\"./images/off.jpg\"); imgArr.push(\"./images/on.jpg\"); var img = document.getElementById(\"pic\"); setInterval(slide, 1000); var index = 0; function slide()&#123; if(index == imgArr.length - 1)&#123; img.src = imgArr[index]; index -= imgArr.length - 1; &#125; else &#123; img.src = imgArr[index]; index += 1; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 代码实现","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"html背景图自适应","slug":"html背景图自适应","date":"2019-08-08T11:05:33.000Z","updated":"2019-08-08T11:13:31.246Z","comments":true,"path":"2019/08/08/html背景图自适应/","link":"","permalink":"http://yoursite.com/2019/08/08/html背景图自适应/","excerpt":"","text":"账号注册页面设计出现问题网页背景图片不能根据浏览器的变大而变大,会出现空白区12345body&#123; background:url('./测试图片/1.jpeg'); background-repeat:no-repeat; background-size:100% 100%&#125;","categories":[],"tags":[{"name":"hmtl","slug":"hmtl","permalink":"http://yoursite.com/tags/hmtl/"}]},{"title":"坦克大战-第四天","slug":"坦克大战-第四天","date":"2019-08-04T13:39:25.000Z","updated":"2019-08-05T02:49:53.348Z","comments":true,"path":"2019/08/04/坦克大战-第四天/","link":"","permalink":"http://yoursite.com/2019/08/04/坦克大战-第四天/","excerpt":"","text":"敌方坦克 1.增加了敌方坦克的随机运动和随机发射子弹,使用了Random类 2.在游戏窗口类中,新增一个成员变量为List enemyTanks = new Arraylist&lt;&gt;(),用于存放多个敌方坦克对象 3.增加了坦克越界的边界检查,如果坦克的位置出界就把位置赋值为老的位置 123456789// 在Direction枚举对象中,增加随机方向的方法public enum Direction &#123; UP, DOWN, LEFT, RIGHT; private static Random rand = new Random(); public static Direction randomDir() &#123; return values()[rand.nextInt(values().length)]; &#125;&#125; 在敌方坦克类(Tank)中加入随机方法的方法 123456private Random rand = New Random();private void setDirection() &#123; if(rand.nextInt(100) &gt; 95)&#123; // 当随机数大于95时再随机设置方式 this.direction = Direction.randomDir(); &#125;&#125; 在游戏窗口类中增加List 1234// 存放敌方坦克对象List&lt;Tank&gt; enemyTanks = new ArrayList&lt;&gt;();// 监听键盘的Y按键, 当按键Y抬起时// add(new Tank(200, 200 , Direction.randomDir, ,Group.Bad)); 增加边界检测 当坦克出界是, 使上步位置赋值给现在的位置, 在进行绘制坦克123456789101112131415161718192021222324252627282930private void boundsCheck() &#123; if(x &lt; 0 || y &lt; 30 || x + this.WIDTH &gt; gf.GAME_WIDTH || y + this.HEIGHT &gt; gf.GAME_HEIGHT) &#123; this.x =this.oldX; this.y = this.oldY; &#125;&#125;// 将此方法加入坦克类的move()方法的最下方// 5):根据方向一直移动private void move() &#123; this.oldX = x; this.oldY = y; setDirection(); switch (direction) &#123; case UP: y -= SPEED; break; case DOWN: y += SPEED; break; case RIGHT: x += SPEED; break; case LEFT: x -= SPEED; break; &#125; boundsCheck(); fire();&#125; 随机时刻发出子弹也是使用Random的对象, 和设置方向的方式一样。上方代码已经创建了Random的对象，因此直接使用rand调用nextInt()方法即可 123456789// 此方法加入move()方法的下方private void fire() &#123; if(rand.nextInt(100) &gt; 95) &#123; if(gf == null)&#123; gf = GameFrame.getInstance; &#125; gf.add(new Bullet(x, y, direction, group)); &#125;&#125; 程序运行结果:","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"坦克大战-第三天","slug":"坦克大战-第三天","date":"2019-08-02T07:43:02.000Z","updated":"2019-08-02T08:49:36.088Z","comments":true,"path":"2019/08/02/坦克大战-第三天/","link":"","permalink":"http://yoursite.com/2019/08/02/坦克大战-第三天/","excerpt":"","text":"主要内容增加了按键控制坦克的方向 监听键盘上下左右按键，进行控制坦克的运行123456789101112131415161718192021222324252627282930313233343536373839404142// 4):设置坦克方向private void setDirection() &#123; if (!isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; !isD) &#123; isMoving = false; &#125; else &#123; isMoving = true; &#125; if (isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; !isD) &#123; direction = Direction.UP; &#125; if (!isU &amp;&amp; isR &amp;&amp; !isL &amp;&amp; !isD) &#123; direction = Direction.RIGHT; &#125; if (!isU &amp;&amp; !isR &amp;&amp; isL &amp;&amp; !isD) &#123; direction = Direction.LEFT; &#125; if (!isU &amp;&amp; !isR &amp;&amp; !isL &amp;&amp; isD) &#123; direction = Direction.DOWN; &#125;&#125;// 5):根据方向一直移动private void move() &#123; if (!isMoving) &#123; return; &#125; switch (direction) &#123; case UP: y -= SPEED; break; case DOWN: y += SPEED; break; case RIGHT: x += SPEED; break; case LEFT: x -= SPEED; break; &#125;&#125; 解决游戏坦克图片闪动严重原因： 由于每次画图需要从内存中读取数据，在一点一点的绘制在窗口上。一边读取一边绘制。读取还为完成，就已经有部分绘制在电脑屏幕上。因此出现闪屏的情况。 解决办法：先将图片绘制在一个和窗口大小一致的offScreemImage上，然后再将该图片一次性画在窗口上。1234567891011121314@Overridepublic void update(Graphics g) &#123; if (offScreenImage == null) &#123; offScreenImage = this.createImage(GAME_WIDTH, GAME_HEIGHT); &#125; Graphics gOffScreen = offScreenImage.getGraphics(); Color c = gOffScreen.getColor(); gOffScreen.setColor(Color.BLACK); gOffScreen.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT); gOffScreen.setColor(c); paint(gOffScreen); g.drawImage(offScreenImage, 0, 0, null);&#125; 画出了敌方坦克12345678910111213141516171819public void paint(Graphics g) &#123; switch (direction) &#123; case UP: g.drawImage(ImagesResource.badTankU, x, y, null); break; case DOWN: g.drawImage(ImagesResource.badTankD, x, y, null); break; case RIGHT: g.drawImage(ImagesResource.badTankR, x, y, null); break; case LEFT: g.drawImage(ImagesResource.badTankL, x, y, null); break; &#125; move();&#125; 增加子弹对象增加X按键，来释放子弹 为了控制子弹的发射速度，采取监听X按键抬起的信号 GameFrame类中，增加代码：123456789101112131415161718192021// 2):得到显卡的画笔public void paint(Graphics g) &#123; myTank.paint(g); if(enemyTank.isLive()) &#123; enemyTank.paint(g); &#125; if (bullets != null) &#123; for (int i = 0; i &lt; bullets.size(); i++) &#123; Bullet bullet = bullets.get(i); bullet.crashWithTank(enemyTank); if(!bullet.isLive()) &#123; bullets.remove(i); &#125;else &#123; bullet.paint(g); &#125; &#125; getBulletCount(g); &#125;&#125; 为了使子弹对象存在多个对象，将对象加入容器中子弹过多会产生内存泄漏，当子弹跑出屏幕或打到敌方坦克删除子弹对象 选择List集合框架中的ArrayList来存放子弹对象 ArrayList bullets = new ArrayList&lt;&gt;()123456789101112if (bullets != null) &#123; for (int i = 0; i &lt; bullets.size(); i++) &#123; Bullet bullet = bullets.get(i); bullet.crashWithTank(enemyTank); if(!bullet.isLive()) &#123; bullets.remove(i); &#125;else &#123; bullet.paint(g); &#125; &#125; getBulletCount(g);&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"坦克大战-第二天","slug":"坦克大战-第二天","date":"2019-07-31T00:46:58.000Z","updated":"2019-07-31T02:33:26.825Z","comments":true,"path":"2019/07/31/坦克大战-第二天/","link":"","permalink":"http://yoursite.com/2019/07/31/坦克大战-第二天/","excerpt":"","text":"坦克类的设计创建一个坦克的类 考虑坦克的属性(位置、方向、速度) 其中方向采用枚举（上、下、左、右） 加载坦克的图片 接受按键的触发，使坦克根据人的控制来动 代码实现方向枚举123Enum Direction &#123; UP, DOWN, LEFE, RIGHT&#125; 图片资源类（例如坦克图片）12345678910111213public class ImagesResource &#123; public static BufferedImage goodTankU, goodTankD, goodTankR, goodTankL; static&#123; try &#123; goodTankU = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankU.gif\")); goodTankD = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankD.gif\")); goodTankL = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankL.gif\")); goodTankR = ImageIO.read(Tank.class.getClassLoader().getResourceAsStream(\"images/p1tankR.gif\")); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 坦克类123456789101112131415161718192021222324252627282930/* 1):得到窗口传递的画笔，绘制自己 2):监听键盘按下 3):监听键盘抬起*/public class Tank &#123; private static final int SPEED = 5; // 坦克的速度 private int x, y; //坦克的初始位置 private Direction direction； // 坦克的方向 public Tank(int x, int y, Direction direction)&#123; this.x = x; this.y = y; this.direction = direction; &#125; // 1):得到窗口传递的画笔，绘制自己 public void paint (Graphics g) &#123; g.drawImage(ImagesResource.goodTankD, x, y, null); &#125; // 2):监听键盘按下 public void keyPressed(KeyEvent e) &#123; &#125; // 3):监听键盘抬起 public void keyReleased(KeyEvent e) &#123; &#125;&#125; 运行结果窗口增加键盘和窗口监听 在游戏窗口类构造器中见添加监听，并把监听信号选择性的传给坦克对象 敌方坦克不需要监听信号，自己的坦克需要。 窗口监听，来关闭程序（点击上方X，进行关闭程序） 12345678910111213141516171819202122232425262728// GameFrame的构造器增加监听public GameFrame ()&#123; . . //省略 ..... . // 键盘监听 this.addKeyListener(new KeyAdapte( @Override public void keyPressed(KeyEvent e) &#123; myTank.keyPressed(e); &#125; @Override public void keyReleased(KeyEvent e) &#123; myTank.keyReleased(e); &#125; )); // 窗口监听 this.addWindowListener(new WinodowAdapte()&#123; @Override public void windowClosing(WindowEvent e) &#123; // 关闭程序 System.exit(0); &#125; &#125;)&#125;","categories":[],"tags":[]},{"title":"坦克大战-第一天","slug":"坦克大战-第一天","date":"2019-07-30T14:19:37.000Z","updated":"2019-07-30T15:30:23.383Z","comments":true,"path":"2019/07/30/坦克大战-第一天/","link":"","permalink":"http://yoursite.com/2019/07/30/坦克大战-第一天/","excerpt":"","text":"第一天创建一个游戏窗口 新建一个GameFrame窗口类（单例设计模式） 设置游戏窗口的属性（长、宽、高、背景颜色、位置等） 给窗口一个画笔，进行绘制图形 在窗口画一个图形进行测试 将画笔交给坦克对象 1234567891011121314151617181920212223242526// 游戏的窗口/* 1):向外暴露自己的实例对象 2):得到显卡的画笔*/public class GameFrame extends Frame &#123; // 创建该类的私有化静态对象 private static final GameFrame instance = new GameFrame(); // 私有化构造器 private GameFrame()&#123; // 初始化窗口数据 this.setTitle(\"Tank War\"); // 窗口标题 this.setLocation(600, 200);// 窗口位置 this.setSize(800, 600);// 窗口大小 this.setVisible(true); // 显示窗口 &#125;; // 1):向外暴露自己的实例对象 public static GameFrame getInstance() &#123; return instance; &#125; // 2):得到显卡的画笔 public void paint(Graphics g) &#123; g.fillRect(100, 100, 50, 50); &#125;&#125; 主方法获取窗口实例对象123456public class Main &#123; public static void maiN(String[] args) &#123; // 获取窗口的实例对象 GameFrame.getInstance(); &#125;&#125; 输出结果","categories":[],"tags":[]},{"title":"坦克大战","slug":"坦克大战","date":"2019-07-30T12:31:38.000Z","updated":"2019-07-30T13:03:29.775Z","comments":true,"path":"2019/07/30/坦克大战/","link":"","permalink":"http://yoursite.com/2019/07/30/坦克大战/","excerpt":"","text":"坦克大战项目的目的 通过项目建立面向对象的设计思维，并复习OO，容器，网络、线程等基础知识 资料 1.阿里手册 2.GUI(不需要深入掌握) 项目安排 1.做一个游戏窗口并显示","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-28T08:49:02.323Z","updated":"2019-07-28T08:49:02.323Z","comments":true,"path":"2019/07/28/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}